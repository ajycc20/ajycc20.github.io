<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[菜鸡的Leecode学习-day04]]></title>
    <url>%2F2019%2F03%2F20%2F%E8%8F%9C%E9%B8%A1%E7%9A%84Leecode%E5%AD%A6%E4%B9%A0-day04%2F</url>
    <content type="text"><![CDATA[报数报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 1. 1 2. 11 3. 21 4. 1211 5. 111221 1 被读作&quot;one 1&quot; (&quot;一个一&quot;),即11。11 被读作&quot;two 1s&quot;(&quot;两个一&quot;),即 21。21 被读作&quot;one 2&quot;,&quot;one 1&quot;`“一个二”,“一个一”),即1211`。 给定一个正整数 n(1 ≤ n ≤ 30)，输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 示例 1: 输入: 1 输出: &quot;1&quot; 示例 2: 输入: 4 输出: &quot;1211&quot; 先分析题目，这题一开始我是一脸懵逼的，后来仔细看了看，主要就是第n行的数字是第n-1行的内容，然后递归 提交时间 状态 执行用时 内存消耗 语言 7 小时前 通过 136 ms 35.5 MB javascript 1234567891011121314151617181920/** * @param &#123;number&#125; n * @return &#123;string&#125; */var countAndSay = function(n) &#123; var res = '1' for (var i = 1; i &lt; n; i++) &#123; var count = 1, str = '' for (var j = 0; j &lt; res.length; j++) &#123; if (res[j] == res[j + 1]) &#123; count++ &#125; else &#123; str += count + res[j] count = 1 &#125; &#125; res = str &#125; return res&#125;; 令初值为1，然后开始迭代n，依此获取每项的结果 当n = 3时 i = 1, str = ‘11’,count = 1i = 2, res[0] == res[1],count = 2i = 2, str = ‘21’,count = 1, res = ‘21’ 最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 提交时间 状态 执行用时 内存消耗 语言 7 小时前 通过 164 ms 35.4 MB javascript 分析，对于最大和的连续子数组，从首位开始相加，小于0则使用新的子数组 12345678910111213141516/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var maxSubArray = function(nums) &#123; var res = nums[0], sum = 0 for (var i of nums) &#123; if (res &gt; 0) &#123; sum += i &#125; else &#123; sum = i &#125; res = Math.max(res, i) &#125; return res&#125;; 初始令res = nums[0],开始遍历，大于0则相加，小于则使用新的子数组，使用Math.max()用以获取新初值 最后一个单词的长度给定一个仅包含大小写字母和空格&#39; &#39;的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例: 输入: &quot;Hello World&quot; 输出: 5 提交时间 状态 执行用时 内存消耗 语言 7 小时前 通过 128 ms 33.7 MB javascript 分析，很简单的一道题，为了防止字符串左右的空格，先使用trim()，之后使用split(&#39; &#39;)，将单词分隔开，获取最后一个即可 1234567891011/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLastWord = function(s) &#123; var str = s.trim().split(' ') if (str.length == 0) &#123; return 0 &#125; return str[str.length - 1].length&#125;; 加一给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例 2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。 提交时间 状态 执行用时 内存消耗 语言 6 小时前 通过 144 ms 33.5 MB javascript 分析，存在两种情况，一种是有9，则有进位，一种正常加一就行 123456789101112131415161718/** * @param &#123;number[]&#125; digits * @return &#123;number[]&#125; */var plusOne = function(digits) &#123; for (var i = digits.length - 1; i &gt;= 0; i--) &#123; if (digits[i] == 9) &#123; digits[i] = 0 &#125; else &#123; digits[i] ++ return digits &#125; &#125; if (i == -1) &#123; digits.unshift(1) &#125; return digits&#125;; 逆序遍历数组，为9则置为0，之后在前一位++，如果不在else处返回则有进位，此时i==-1，使用unshift首位+1 二进制求和给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字1和0。 示例 1: 输入: a = &quot;11&quot;, b = &quot;1&quot; 输出: &quot;100&quot; 示例 2: 输入: a = &quot;1010&quot;, b = &quot;1011&quot; 输出: &quot;10101&quot; 提交时间 状态 执行用时 内存消耗 语言 5 小时前 通过 144 ms 35.2 MB javascript 分析，偷鸡做法，使用parseInt，存在数值范围，超出则gg 123var addBinary = function(a, b) &#123; return (parseInt(a, 2) + parseInt(b, 2)).toString(2)&#125; 123456789101112131415161718192021222324252627282930/** * @param &#123;string&#125; a * @param &#123;string&#125; b * @return &#123;string&#125; */var addBinary = function(a, b) &#123; var len = a.length &gt; b.length ? a.length : b.length, res = [], carry = 0 var a = a.split('').reverse(), b = b.split('').reverse() for (var i = 0; i &lt; len; i++) &#123; var sum = +(a[i] || 0) + +(b[i] || 0) + carry if (sum == 0) &#123; res[i] = 0 carry = 0 &#125; else if (sum == 1) &#123; res[i] = 1 carry = 0 &#125; else if (sum == 2) &#123; res[i] = 0 carry = 1 &#125; else &#123; res[i] = 1 carry = 1 &#125; &#125; if (carry == 1) &#123; res.push(1) &#125; return res.reverse().join('')&#125;; 定义len取字符串最长长度，然后翻转字符串，定义carry作为进位值，由值来决定结果和进位。+指类型转换，不能转换则置0. 最终有进位则 push(1),然后翻转字符串。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Leecode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸡的Leecode学习-day03]]></title>
    <url>%2F2019%2F03%2F18%2F%E8%8F%9C%E9%B8%A1%E7%9A%84Leecode%E5%AD%A6%E4%B9%A0-day03%2F</url>
    <content type="text"><![CDATA[删除排序数组中的重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 提交时间 状态 执行用时 内存消耗 语言 4 天前 解答错误 N/A N/A javascript 4 天前 通过 192 ms 36.8 MB javascript 解答错误： 提交记录 输入： [1,1,2] 输出： [1,0,1,2] 预期： [1,2] 12345678910111213141516/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; var len = 1 var index = nums[0] for (var i in nums) &#123; if (i != index) &#123; nums[len++] = i index = i &#125; &#125; return len&#125;; for (var i in nums) 使用了in遍历所以出错了 for in是ES5标准，遍历key. for of是ES6标准，遍历value. 正确提交：12345678910111213141516/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; var len = 1 var index = nums[0] for (var i of nums) &#123; if (i != index) &#123; nums[len++] = i index = i &#125; &#125; return len&#125;; 有效的括号给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1: 输入: &quot;()&quot; 输出: true 示例 2: 输入: &quot;()[]{}&quot; 输出: true 示例 3: 输入: &quot;(]&quot; 输出: false 示例 4: 输入: &quot;([)]&quot; 输出: false 示例 5: 输入: &quot;{[]}&quot; 输出: true 提交时间 状态 执行用时 内存消耗 语言 3 天前 通过 124 ms 33.5 MB javascript 12345678910111213141516171819/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function(s) &#123; var list = [] for (var i = 0; i &lt; s.length; i++) &#123; if (s[i] == '(') &#123; list.push(')') &#125; else if (s[i] == '[') &#123; list.push(']') &#125; else if (s[i] == '&#123;') &#123; list.push('&#125;') &#125; else if (list.pop() != s[i]) &#123; return false &#125; &#125; return !list.length&#125;; 用栈来做，为左括号则入栈，右括号出栈，出栈顺序有问题则返回false。 移除元素给定一个数组nums和一个值val，你需要原地移除所有数值等于val的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 怎么说呢，感觉和前面删除排序数组中的重复项类似吧 提交时间 状态 执行用时 内存消耗 语言 3 天前 通过 108 ms 33.8 MB javascript 3 天前 解答错误 N/A N/A javascript 错误提交： 提交记录 输入： [0,1,2,2,3,0,4,2]2 输出： [0,1,0,3,0] 预期： [0,1,4,0,3] 123456789101112131415/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; val * @return &#123;number&#125; */var removeElement = function(nums, val) &#123; var len = 0 for (var i of nums) &#123; if (nums[i] != val) &#123; nums[len++] = nums[i] &#125; &#125; return len&#125;; 没仔细想感觉和前面题类似 顺便不正常了那么一会瞎写了for of，一脸懵逼的nums[i]。。。。 正确提交： 123456789101112131415161718/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; val * @return &#123;number&#125; */var removeElement = function(nums, val) &#123; var len = 0 if (nums == null || nums.length == 0) &#123; return 0 &#125; for (var i of nums) &#123; if (i != val) &#123; nums[len] = i len++ &#125; &#125; return len&#125;; 在数组不为0的情况下，遍历。。。。。。。 然后存进去就是了。 实现strStr()实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot; 输出: 2 示例 2: 输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot; 输出: -1 说明: 当needle是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当needle是空字符串时我们应当返回 0 。这与C语言的strstr()以及 Java的 indexOf()定义相符。 提交时间 状态 执行用时 内存消耗 语言 3 天前 通过 124 ms 33.4 MB javascript 1234567891011/** * @param &#123;string&#125; haystack * @param &#123;string&#125; needle * @return &#123;number&#125; */var strStr = function(haystack, needle) &#123; if (needle == '') &#123; return 0 &#125; return haystack.indexOf(needle)&#125;; 代码emmm 就当不存在吧。 如果考kmp算法 分类简单就2333 不考吧 内置函数emmm 溜了溜了~~~ 搜索插入位置给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0 提交时间 状态 执行用时 内存消耗 语言 3 天前 通过 116 ms 33.6 MB javascript 1234567891011121314/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number&#125; */var searchInsert = function(nums, target) &#123; for (var i = 0; i &lt; nums.length; i++) &#123; if (target &lt;= nums[i]) &#123; return i &#125; else if (target &gt; nums[nums.length - 1]) &#123; return nums.length &#125; &#125;&#125;; 感觉是我碰到的最简单的一道题了。。 当然数据多了还是二分查找快。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Leecode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸡的Leecode学习-day02]]></title>
    <url>%2F2019%2F03%2F17%2F%E8%8F%9C%E9%B8%A1%E7%9A%84Leecode%E5%AD%A6%E4%B9%A0-day02%2F</url>
    <content type="text"><![CDATA[一周前做的了，今天刚好有空写到blog里，以后尽量每天一次吧 只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入：[2,2,1] 输出：1 示例 2: 输入: [4,1,2,1,2] 输出: 4 提交时间 状态 执行用时 内存消耗 语言 10 天前 通过 156 ms 35.2 MB javascript 12345678910/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var singleNumber = function(nums) &#123; for(var i = 1; i &lt; nums.length; i++)&#123; nums[0] = nums[0] ^ nums[i] &#125; return nums[0]&#125;; 其余元素均出现两次，只有所求元素一次，所以异或即可 求众数给定一个大小为n的数组，找到其中的众数。众数是指在数组中出现次数大于[n/2]的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3] 输出: 3 示例 2: 输入: [2,2,1,1,1,2,2] 输出: 2 提交时间 状态 执行用时 内存消耗 语言 10 天前 通过 108 ms 38.2 MB javascript 123456789101112131415161718/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var majorityElement = function(nums) &#123; var res = 0, count = 0 for (var num of nums)&#123; if (count === 0) &#123; res = num count++ &#125; else if (res === num) &#123; count++ &#125; else &#123; count-- &#125; &#125; return res&#125;; 先假设res为第一个数，开始遍历，相同+1,不同-1,如果count===0，res下一个数继续，最终可获得结果。 搜索二维矩阵编写一个高效的算法来搜索mxn矩阵matrix中的一个目标值target。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回true。 给定 target = 20，返回false。 提交时间 状态 执行用时 内存消耗 语言 10 天前 通过 180 ms 37.3 MB javascript 10 天前 执行出错 N/A N/A javascript 10 天前 执行出错 N/A N/A javascript 10 天前 通过 768 ms 37 MB javascript 执行用时768ms1234567891011121314/** * @param &#123;number[][]&#125; matrix * @param &#123;number&#125; target * @return &#123;boolean&#125; */var searchMatrix = function(matrix, target) &#123; for(let i = 0; i &lt; matrix.length; i++) &#123; for (let j = 0; j &lt; matrix[0].length; j++)&#123; if(matrix[i][j] === target)&#123; return true &#125; &#125; &#125;return false&#125;; 感觉应该很无脑了2333，直接遍历所有。 执行用时180ms1234567891011121314151617181920212223/** * @param &#123;number[][]&#125; matrix * @param &#123;number&#125; target * @return &#123;boolean&#125; */var searchMatrix = function(matrix, target) &#123; if(matrix.length &lt; 1 || matrix.length[0] &lt; 1) &#123; return false &#125; let row = matrix.length, col = matrix[0].length, i = row - 1, j = 0 while(i &gt;= 0 &amp;&amp; j &lt; col) &#123; if (matrix[i][j] &gt; target) &#123; i-- &#125; else if (matrix[i][j] &lt; target) &#123; j++ &#125; else if (matrix[i][j] === target)&#123; return true &#125; else &#123; return false &#125; &#125; return false&#125;; 取矩阵左下角为锚点，其余元素有个特性，在其上的总小于锚点值，右边的总大于锚点值。之后比较大小即可。 合并两个有序数组给定两个有序整数数组nums1和nums2,将nums2合并到nums1中，使得num1成为一个有序数组。 说明: 初始化nums1和nums2的元素数量分别为m和n。你可以假设nums1有足够的空间（空间大小大于或等于 m + n）来保存nums2中的元素。示例: 输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 提交时间 状态 执行用时 内存消耗 语言 10 天前 通过 104 ms 34.6 MB javascript 1234567891011121314/** * @param &#123;number[]&#125; nums1 * @param &#123;number&#125; m * @param &#123;number[]&#125; nums2 * @param &#123;number&#125; n * @return &#123;void&#125; Do not return anything, modify nums1 in-place instead. */var merge = function(nums1, m, nums2, n) &#123; nums1 = nums1.reverse() for (let i = 0; i &lt; nums2.length; i++) &#123; nums1[i] += nums2[i] &#125; nums1 = nums1.sort((a,b) =&gt; &#123;return a - b&#125;)&#125;; 取巧写法~~~ 捂脸···]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Leecode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript继承]]></title>
    <url>%2F2019%2F03%2F09%2FJavaScript%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[接之前的坑，重新复习一遍继承 原型链Js中描述了原型链的概念，并将原型链作为实现继承的主要方法。基本思想便是利用原型让一个引用类型继承另一个引用类型的属性和方法。 实现原型链的基本模式123456789101112131415161718192021function SuperType () &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function () &#123; return this.property;&#125;function SubType () &#123; this.subproperty = false;&#125;// 继承了 SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function () &#123; return this.subproperty;&#125;var instance = new SubType();alert(instance.getSuperValue()); // true SubType继承自SuperType。继承通过创建SuperType的示例，并将该实例赋给SubType.prototype实现。本质为重写原型对象，代之以一个新类型的示例。确立继承之后，再在SubType.prototype添加一个方法，这样就在继承SuperType的属性和方法基础上添加了新方法。 总之，SubType继承SuperType，SuperType继承自Object。当调用instance.toString()时，实际调用的是保存在Object.prototype中的方法。 子类重写超类中的方法或者添加超类不存在的方法时，一定要放在替换原型的语句之后。 存在的问题： 包含引用类型值的原型。 eg.123456789101112131415function SuperType() &#123; this.colors = ["red", "blue", "green"];&#125;function SubType() &#123;&#125;// 继承SubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push("black");alert(instance1.colors); // "red,blue,green,black"var instance2 = new SubType();alert(instance2.colors); // "red,blue,green,black" 结果显而易见，子类的所有实例共享属性。 创建子类型实例时，不能向超类型的构造函数中传递参数。(无法再不影响所有对象实例的情况下，给超类的构造函数传递参数) 实际很少单独使用原型链方法 借用构造函数 借用构造函数(constructor stealing),即(伪造对象或经典继承).通过在子类型构造函数的内部调用超类型构造函数实现。使用apply()和call()`方法。 123456789101112131415function SuperType() &#123; this.colors = ["red", "blue", "green"];&#125;function SubType() &#123; // 继承 SuperType.call(this);&#125;var instance1 = new SubType();instance1.colors.push("black");alert(instance1.colors); // "red,blue,green,black"var instance2 = new SubType();alert(instance2.colors); // "red,blue,green" 上式通过在SubType()实例下调用了SuperType构造函数。 相对于原型链方式的优势 1234567891011121314function SuperType(name) &#123; this.name = name;&#125;function SubType() &#123; // 继承，传递参数 SuperType.call(this, "Nicholas"); // 实例属性 this.age = 29;&#125;var instance = new SubType();alert(instance.name); // Nicholasalert(instace.age); // 29 SuperType()只接受一个参数，在SubType()构造函数中调用会为SubType()实例设置 name属性。在此之后再添加应该在子类型中定义的属性防止SuperType()构造函数重写子类属性。 存在的问题 函数无法复用，超类原型定义的方法子类也不可见，即所有类型只能使用构造函数模式。 因此很少单独使用构造函数方式 组合继承组合继承(combination inheritance),经典伪继承，即将原型链和构造函数方式合用，从而发挥二者之长。 思路是使用原型链实现对原型属性和方法的继承，通过构造函数实现对实例属性的继承。既保证在原型上定义方法实现了函数复用，又保证每个实例都有自己的属性。1234567891011121314151617181920212223242526272829303132function SuperType(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;function SubType(name, age) &#123; // 继承属性 SuperType.call(this, name); this.age = age;&#125;// 继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() &#123; alert(this.age);&#125;var instance1 = new SubType("Nicholas", 29);instance1.colors.push("black");alert(instance1.colors); // "red,blue,green,black"instance1.sayName(); // "Nicholas"instance1.sayAge(); // 29var instance2 = new SubType("Greg", 27);alert(instance2.colors); // "red,blue,green"instance2.sayName(); // "Greg"instance2.sayAge(); // 27 原型式继承 在object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。 1234567891011121314var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"]&#125;;var person1 = object(person);person1.name = "Greg";person1.friends.push("Rob");var person2 = object(person);person2.name = "Linda";person2.friends.push("Barbie");alert(person.friends); // "Shelby,Court,Van,Rob,Barbie 寄生式继承 寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。 1234567function createAnother(original) &#123; var clone = object(original); // 通过调用函数创建一个对象 clone.sayHi = function() &#123; // 以某种方式来增强这个对象 alert("hi"); &#125;; return clone; //返回这个对象&#125; 使用如下1234567var person = &#123; name: 'Nicholas', friends: ["Shelby", "Court", "Van"]&#125;;var person1 = createAnother(person);person1.sayHi(); // "hi" 寄生组合式继承 组合式继承无论什么情况下都会调用两次超类构造函数，一次是创建子类型原型，一次是子类型构造函数内部。 123456789101112131415161718192021function SuperType(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;function SubType(name, age) &#123; // 继承属性 SuperType.call(this, name); // 第二次调用SuperType() this.age = age;&#125;// 继承方法SubType.prototype = new SuperType(); // 第一次调用 SuperType()SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() &#123; alert(this.age);&#125; 第一次调用时SubType.prototype得到两个属性:name、colors(此时位于SubType原型).第二次调用SubType时在新对象上创建了实例属性name和colors。新创建的属性屏蔽了原型中的同名属性。 寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。 基本思路：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已 本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。 eg.12345function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); // 创建对象 prototype.constructor = subType; // 增强对象 subType.prototype = prototype; // 指定对象&#125; 上式inheritPrototype()接收两个参数：子类构造函数和超类构造函数。 在函数内部： 创建超类原型的副本 为创建的副本添加constructor属性，弥补因重写原型失去的默认constructor属性 将新创建的对象赋值给子类型的原型。 12345678910111213141516171819function SuperType(name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function() &#123; alert(this.age);&#125; 这个例子的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了在SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用instanceof和isPrototypeOf()。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript引用类型的Array类型]]></title>
    <url>%2F2019%2F03%2F04%2FJavaScript%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84Array%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[鄙渣学了一学期的JavaScript，无奈并没有学通，最终还是祭出了Js红宝书，从头预习 转换方法所有对象都具有 toLocaleString()、toString()和valueOf()方法。 12345678910111213141516171819var person1 = &#123; toLocaleString : function () &#123; return "Nikolaos"; &#125;, toString : function() &#123; return "Nikolaos"; &#125;&#125;;var person2 = &#123; toLocaleString : function () &#123; return "Grigorios"; &#125;, toString : function () &#123; return "Greg"; &#125;&#125;; 1234var people = [person1, person2];alert(people); // Nicholas,Gregalert(people.toString()); // Nicholas,Gregalert(people.toLocaleString()); // Nicholas,Grigorios RT,默认调用的是toString()同下一行显式调用。 eg:可以使用join()更改字符串的分隔方式12var colors = ["red", "green", "blue"];alert(colors.join("|")); // red|green|blue 栈方法栈即是需要后进先出的，Js也为此提供了push()和pop()方法用以实现栈的LIFO(Last-In-First-Out)。 123456789101112var colors = new Array();var count = colors.push("red", "green");alert(count); // 2alert(colors); // red,greencount = colors.push("black");alert(count); // 3alert(colors); // red,green,blackvar item = colors.pop();alert(item); // "black"alert(colors.length); // 2 队列方法队列的访问方式是FIFO(First-In-First-Out)，Js也有相应的shift()和unshift()方法。 12345678910111213var colors = new Array();var count = colors.push("red", "green");alert(count); // 2alert(colors); // red,greencount = colors.push("black");alert(count); // 3alert(colors); // red,green,blackvar item = colors.shift();alert(item); // "red"alert(colors.length); // 2alert(colors); // green, black unshift()用以在数组前段添加任意个项并返回新数组长度。 重排序方法reverse()和sort(). 123var values = [1, 2, 3, 4, 5];values.reverse();alert(values); // 5, 4, 3, 2, 1 sort()的弊端.123var values = [0, 1, 5, 10, 15];values.sort();alert(values); // 0, 1, 10, 15, 5 改进方式123456789101112131415function compare(value1, value2)&#123; if (value1 &lt; value2)&#123; return -1; &#125; else if(value1 &gt; value2)&#123; return 1; &#125; else&#123; return 0; &#125;&#125;var values = [0, 1, 5, 10, 15];values.sort(compare);alert(values); // 0, 1, 5, 10, 15 操作方法concat().创建当前数组的副本，并将接收到的参数添加到副本的末尾，并返回新的数组。12345var colors = ["red", "green", "blue"];var colors2 = colors.concat("yellow", ["black", "brown"]);alert(colors); // red,green,bluealert(colors2); // red,green,blue,yellow,black,brown slice().基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。 123456var colors = ["red", "green", "blue", "yellow", "purple"];var colors2 = colors.slice(1);var colors3 = colors.slice(1, 4);alert(colors2); // green,blue,yellow,purplealert(colors3); // green,blue,yellow splice().有如下三种方法 删除: 指定2个参数，要删除的第一项的位置和要删除的项数。 插入: 指定3个参数，起始位置、0(要删除的项数)和要插入的项。 替换: 指定3个参数，起始位置、要删除的项数和要插入任意数量的项。 123456789101112var colors = ["red", "green", "blue"];var removed = colors.splice(0,1); // 删除第一项alert(colors); // green,bluealert(removed); // red，返回的数组中只包含一项removed = colors.splice(1, 0, "yellow", "orange"); // 从位置1开始插入两项alert(colors); // green,yellow,orange,bluealert(removed); // 返回的是一个空数组removed = colors.splice(1, 1, "red", "purple"); // 插入两项，删除一项alert(colors); // green,red,purple,orange,bluealert(removed); // yellow，返回的数组中只包含一项 位置方法indexOf()和lastIndexOf().均接收两个参数：要查找的项和(可选)查找起点位置的索引。 123456789101112131415var numbers = [1,2,3,4,5,4,3,2,1];alert(numbers.indexOf(4)); //3alert(numbers.lastIndexOf(4)); //5alert(numbers.indexOf(4, 4)); //5alert(numbers.lastIndexOf(4, 4)); //3var person = &#123; name: "Nicholas" &#125;;var people = [&#123; name: "Nicholas" &#125;];var morePeople = [person];alert(people.indexOf(person)); //-1alert(morePeople.indexOf(person)); //0 迭代方法 every():对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回true。 filter():对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。 forEach():对数组中的每一项运行给定函数，无返回值。 map():对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some():对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。 1234567var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(everyResult); //false 1234567var numbers = [1,2,3,4,5,4,3,2,1];var filterResult = numbers.filter(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(filterResult); // [3, 4, 5, 4, 3] 1234567var numbers = [1,2,3,4,5,4,3,2,1];var mapResult = numbers.map(function(item, index, array)&#123; return item * 2;&#125;);alert(mapResult); // [2, 4, 6, 8, 10, 8, 6, 4, 2] 123456var numbers = [1,2,3,4,5,4,3,2,1];numbers.forEach(function(item, index, array)&#123; //执行操作 // forEach 本质上等同于使用for循环&#125;) 1234567var numbers = [1,2,3,4,5,4,3,2,1];var someResult = numbers.some(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(someResult); //true 归并方法 reduce():迭代数组所有项，从左向右。 reduceRight():迭代数组所有项，从右向左。 1234567var values = [1, 2, 3, 4, 5];var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum); // 15 初次执行，prev = 1, cur = 2 第二次执行，prev = 3, cur = 3 持续到遍历所有项 reduceRight()同理。 初次执行，prev = 5, cur = 4 第二次执行，prev = 9, cur = 3 持续到遍历所有项]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸡的Leecode学习-day01]]></title>
    <url>%2F2019%2F02%2F26%2F%E8%8F%9C%E9%B8%A1%E7%9A%84Leecode%E5%AD%A6%E4%B9%A0-day01%2F</url>
    <content type="text"><![CDATA[写在最先 之前博客用的个人域名然后放在vultr上，前阵子不知道怎么出问题了，访问特别困难，后来发现dnspod解析也需要备案，思来想去干脆直接在github上写了，以前那点文章也懒得恢复了！ 最近开始在Leecode上刷题，先从简单的开始，嘿嘿！刚好在博客上也做一番记录，算是让自己记忆更深吧。 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例： 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 提交时间 状态 执行用时 内存消耗 语言 14 天前 通过 52 ms 8.1 MB python3 14 天前 通过 7976 ms 7.3 MB python3 第一次提交的堪堪没有超时，因为是直接双for循环暴力解决的。。。1234567891011121314class Solution: def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if len(nums) &lt; 2: return for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == target: return[i, j] 后来仔细想了想用了dict解决，效率还好。1234567891011121314class Solution: def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ dict = &#123;&#125; for i in range(len(nums)): temp = target - nums[i] if nums[i] in dict: return [dict[nums[i]], i] else: dict[temp] = i 整数反转给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。示例1： 输入: 123 输出: 321 示例2： 输入: -123 输出: -321 示例3： 输入: 120 输出: 21 注意：假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31^, 2^31^ − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 提交时间 状态 执行用时 内存消耗 语言 8 小时前 通过 140 ms 13.3 MB python3 8 小时前 解答错误 N/A N/A python3 8 小时前 执行出错 N/A N/A python3 不得不说还是太粗心大意，一开始都没看到示例2，3，就直接提交，直接执行出错了。 第一次的代码：12345678910class Solution: def reverse(self, x: int) -&gt; int: x = str(x) y = '' for i in x: y = i + y y = int(y) if -2**31&lt;y&lt;2**31-1: return y return 0 提交记录 执行出错信息： Line 7: ValueError: invalid literal for int() with base 10: ‘321-‘ 最后执行的输入： -123 第二次的代码：123456789101112131415class Solution: def reverse(self, x: int) -&gt; int: x1 = str(x) y = '' x = '' if x1[0] == '-': x += '-' for i in x1: y = i + y y = y.rstrip('-') y = x + y y = int(y) if -2**31&lt;y&lt;2**31-1: print(y) return 0 提交记录 输入： 123 输出： 0 预期： 321 最终提交如下，strip方法真的是这次用了才熟悉了。123456789101112131415class Solution: def reverse(self, x: int) -&gt; int: x1 = str(x) y = '' x = '' if x1[0] == '-': x += '-' for i in x1: y = i + y y = y.rstrip('-') y = x + y y = int(y) if -2**31&lt;y&lt;2**31-1: return y return 0 回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 好吧，我想说不能23333，真的是菜鸡本菜了 提交时间 状态 执行用时 内存消耗 语言 8 小时前 通过 276 ms 13.5 MB python3 8 小时前 解答错误 N/A N/A python3 第一次提交代码如下：1234567891011class Solution: def isPalindrome(self, x: int) -&gt; bool: str_x = str(x) y = '' if str_x[0] == '-': return False for i in str_x: y = i + y y = int(y) if x == y: return True 提交记录 输入： 10 输出： null 预期： false 最终结果如下：12345678910111213class Solution: def isPalindrome(self, x: int) -&gt; bool: str_x = str(x) y = '' if str_x[0] == '-': return False for i in str_x: y = i + y y = int(y) if x == y: return True else: return False 罗马数字转整数罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: &quot;III&quot; 输出: 3 示例 2: 输入: &quot;IV&quot; 输出: 4 示例 3: 输入: &quot;IX&quot; 输出: 9 示例 4: 输入: &quot;LVIII&quot; 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5: 输入: &quot;MCMXCIV&quot; 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 这题我一开始真的是， 我枯了emmm，思来想去最后用了n个if解决了。。。。。。 提交时间 状态 执行用时 内存消耗 语言 7 小时前 通过 248 ms 13.4 MB python3 7 小时前 解答错误 N/A N/A python3 本来以为第一次提交就直接ok，没想到出错了。。12345678910111213141516171819202122232425262728293031class Solution: def romanToInt(self, s: str) -&gt; int: dict = &#123;'I': 1,'V': 5,'X': 10, 'L': 50,'C': 100,'D': 500,'M': 1000&#125; sum = 0 if len(s) == 1: return dict[s] for i in range(len(s)): if s[i-1] == 'I': if s[i] == 'V' or s[i] == 'X': sum -= 1 else: sum += 1 if s[i-1] == 'V': sum += 5 if s[i-1] == 'X': if s[i] == 'L' or s[i] == 'C': sum -= 10 else: sum += 10 if s[i-1] == 'L': sum += 50 if s[i-1] == 'C': if s[i] == 'D' or s[i] == 'M': sum -= 100 else: sum += 100 if s[i-1] == 'D': sum += 500 if s[i-1] == 'M': sum += 1000 return sum 提交记录 输入： “MMMCDXC” 输出： 3290 预期： 3490 放debug里面跑了一遍才发现是Python for循环的问题。如下改用while循环后正常了。123456789101112131415161718192021222324252627282930313233343536class Solution: def romanToInt(self, s: str) -&gt; int: dict = &#123;'I': 1,'V': 5,'X': 10, 'L': 50,'C': 100,'D': 500,'M': 1000&#125; sum = 0 i = 0 if len(s) == 1: return dict[s] s = s + ' ' while i &lt; len(s): if i == 0: i += 1 if s[i-1] == 'I': if s[i] == 'V' or s[i] == 'X': sum -= 1 else: sum += 1 if s[i-1] == 'V': sum += 5 if s[i-1] == 'X': if s[i] == 'L' or s[i] == 'C': sum -= 10 else: sum += 10 if s[i-1] == 'L': sum += 50 if s[i-1] == 'C': if s[i] == 'D' or s[i] == 'M': sum -= 100 else: sum += 100 if s[i-1] == 'D': sum += 500 if s[i-1] == 'M': sum += 1000 i += 1 return sum 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] 输出: &quot;fl&quot; 示例 2: 输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;] 输出: &quot;&quot; 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。|提交时间|状态|执行用时|内存消耗|语言||:——:|:——:|:——:|:——:|:——:||7 小时前| 通过 |56 ms |13.2 MB| python3| 这道题我一开始想偏了，一直想着怎么遍历怎么怎么，半天解决不了。最后本菜只能参考官方题解Java版然后用Python写了出来 下面是官方题解12345678910 public String longestCommonPrefix(String[] strs) &#123; if (strs.length == 0) return ""; String prefix = strs[0]; for (int i = 1; i &lt; strs.length; i++) while (strs[i].indexOf(prefix) != 0) &#123; prefix = prefix.substring(0, prefix.length() - 1); if (prefix.isEmpty()) return ""; &#125; return prefix;&#125; 下面是我用Python改了一遍的。(哭~~） Python 没有indexof这里想到了用find替代，然后下面切割字符串刚刚好Python的切片。12345678910111213141516class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: i = 1 if len(strs) == 0: return '' if len(strs) == 1: return strs[0] if len(strs) &gt; 1: temp = strs[0] while i &lt; len(strs): while strs[i].find(temp) != 0: temp = temp[0:len(temp) - 1] if temp == '': return '' i += 1 return temp 慢慢来吧。菜鸡终有出头日]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Leecode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
