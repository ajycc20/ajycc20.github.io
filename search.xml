<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Reflect对象]]></title>
    <url>%2F2019%2F04%2F03%2FReflect%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[静态方法 Reflect对象一共有13个静态方法，如下 Reflect.apply(target, thisArg, args) Reflect.construct(target, args) Reflect.get(target, name, receiver) Reflect.set(target, name, value, receiver) Reflect.defineProperty(target, name, desc) Reflect.deleteProperty(target, name) Reflect.has(target, name) Reflect.ownKeys(target) Reflect.isExtensible(target) Reflect.preventExtensions(target) Reflect.getOwnPropertyDescriptor(target, name) Reflect.getPrototypeOf(target) Reflect.setPrototypeOf(target, prototype) Reflect.get(target, name, receiver) Reflect.get()查找并返回target对象的name属性，如果没有则返回undefined 1234567891011var myObject = &#123; foo: 1, bar: 2, get baz() &#123; return this.foo + this.bar &#125;&#125;Reflect.get(myObject, 'foo') // 1Reflect.get(myObject, 'bar') // 2Reflect.get(myObject, 'baz') // 3 如果name属性部署了读取函数getter，则读取函数的this绑定receiver 1234567891011121314151617var myObject = &#123; foo: 1, bar: 2, get baz () &#123; return this.foo + this.bar &#125;&#125;var myReceiverObject = &#123; foo: 4, bar: 4&#125;Reflect.get(myObject, 'baz', myReceiverObject) // 8// 如果第一个参数不是对象，Reflect.get报错Reflect.get(1, 'foo') // 报错Reflect.get(false, 'foo') // 报错 Reflect.set(target, name, value, receiver) Reflect.set()设置target对象的name属性等于value1234567891011121314var myObject = &#123; foo: 1, set bar (value) &#123; return this.foo = value &#125;&#125;myObject.foo // 1Reflect.set(myObject, 'foo', 2)myObject.foo // 2Reflect.set(myObject, 'bar', 3)myObject.foo // 3 如果name属性设置了赋值函数，则赋值函数的this绑定receiver 123456789101112131415161718var myObject = &#123; foo: 4, set bar (value) &#123; return this.foo = value &#125;&#125;var myReceiverObject = &#123; foo: 0&#125;Reflect.set(myObject, 'bar', 1, myReceiverObject)myObject.foo // 4myReceiverObject.foo // 1// 如果第一个参数不是对象，Reflect.setReflect.set(1, 'foo', &#123;&#125;) // 报错Reflect.set(false, 'foo', &#123;&#125;) // 报错 注意，Reflect.set会触发Proxy.defineProperty拦截 1234567891011121314151617181920let p = &#123; a: 'a'&#125;let handler = &#123; set (target, key, value, receiver) &#123; console.log('set') Reflect.set(target, key, value, receiver) &#125;, defineProperty (target, key, attribute) &#123; console.log('defineProperty') Reflect.defineProperty(target, key, attribute) &#125;&#125;let obj = new Proxy(p, handler)obj.a = 'A'//set//defineProperty 上述代码，Proxy.set 拦截使用了Reflect.set, 导致触发了Proxy.defineProperty拦截 Reflect.has(obj, name) Reflect.has()对应 name in obj中的in运算符123456789var myObject = &#123; foo: 1&#125;//old'foo' in myObject // true//newReflect.has(myObject, 'foo') // true 如果第一个参数不是对象，Reflect.has和in运算符都会报错 Reflect.deleteProperty(obj, name) Reflect.deleteProperty()等同于delete obj[name], 用于删除对象的属性123456789const myObj = &#123; foo: 'bar'&#125;// olddelete myObj.foo// newReflect.deleteProperty(myObj, 'foo') 该方法返回一个布尔值，如果删除成功或者被删除属性不存在则返回true，如果删除失败或者被删除属性依然存在则返回false Reflect.construct(target, args) Reflect.construct()等同于new target(…args),提供了一种不适用new来调用构造函数的方法12345678910function Greeting (name) &#123; this.name = name&#125;// new的写法const instance = new Greeting('张三')// Reflect.construct写法const instance = Reflect.construct(Greeting, ['张三']) Reflect.getPrototypeOf(obj) Reflect.getPrototypeOf()用于读取对象的proto属性，对应Object.getPrototypeOf(obj)1234567const myObj = new FancyThing()// oldObject.getPrototypeOf(myObj) === FancyThing.prototype// newReflect.getPrototypeOf(myObj) === FancyThing.prototype Reflect.getPrototypeOf和Object.getPrototypeOf的区别是，如果参数不是对象，后者会将这个参数转为对象，再运行，前者直接报错 Reflect.setPrototypeOf(obj, newProto) Reflect.setPrototypeOf()用于设置对象的proto属性，返回第一个参数对象，对应Object.setPrototypeOf(obj, newProto)1234567const myObj = new FancyThing()// oldObject.setPrototypeOf(myObj, OtherThing.prototype)// newReflect.setPrototypeOf(myObj, OtherThing.prototype) 如果第一个参数不是对象，Object.setPrototypeOf会返回第一个参数本身，Reflect.setPrototypeOf会报错 如果第一个参数是undefined或null,两者都会报错 Reflect.apply(func, thisArg, args) Reflect.apply()等同于Function.prototype.apply.call(func, thisArg, args),用于绑定this对象后执行给定函数1234567891011const ages = [11, 33, 12, 54, 18, 96]// oldconst youngest = Math.min.apply(Math, ages)const oldest = Math.max.apply(Math, ages)const type = Object.prototype.toString.call(youngest)// newconst youngest = Reflect.apply(Math.min, Math, ages)const oldest = Reflect.apply(Math.max, Math, ages)const type = Reflect.apply(Object.prototype.toString, youngest, []) Reflect.defineProperty(target, propertyKey, attrubutes) Reflect.defineProperty()基本等同于Object.defineProperty，来为对象定义属性12345678910111213function MyDate () &#123; /*...*/&#125;// oldObject.defineProperty(MyDate, 'now', &#123; value: () =&gt; Date.now()&#125;)// new Reflect.defineProperty(MyDate, 'now', &#123; value: () =&gt; Date.now()&#125;) 如果第一个参数不是对象，Reflect.defineProperty就会报错 Reflect.getOwnPropertyDescriptor(target, propertyKey) Reflect.getOwnPropertyDescriptor()基本等同于Object.getOwnPropertyDescriptor,用于获得指定属性的描述对象，将来会替代后者1234567891011var myObject = &#123;&#125;Object.defineProperty(myObject, 'hidden', &#123; value: true, enumerable: false&#125;)// oldvar theDescriptor = Object.getOwnPropertyDescriptor(myObject, 'hidden')// newvar theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, 'hidden') 如果第一个参数不是对象, Object…会返回undefined,Reflect…会抛出错误，表示参数非法 Reflect.isExtensible(target) Reflect.isExtensible()对应的Object.isExtensible,返回一个布尔值，表示当前对象是否可扩展1234567const myObject = &#123;&#125;// oldObject.isExtensible(myObject) // true// new Reflect.isExtensible(myObject) // true 如果参数不是对象，Object.isExtensible会返回false，Reflect.isExtensible会报错 Reflect.preventExtensions(target) Reflect.preventExtensions()对应Object.preventExtensions()，用于使一个对象变为不可扩展的。返回一个布尔值，表示是否操作成功1234567var myObject = &#123;&#125;// oldObject.preventExtensions(myObject) // Object &#123;&#125;// new Reflect.preventExtensions(myObject) // true 如果参数不是对象，Object..在ES5下报错，ES6返回传入的参数，Reflect…报错 Reflect.ownKeys(target) Reflect.ownKeys()用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames 与Object.getOwnPropertySymbols之和12345678910111213var myObject = &#123; foo: 1, bar: 2, [Symbol.for('baz')]: 3, [Symbol.for('bing')]: 4&#125;// oldObject.getOwnPropertyNames(myObject) // ['foo', 'bar']Object.getOwnPropertySymbols(myObject) // [Symbol(baz), Symbol(bing)]// newReflect.ownKeys(myObject) // ['foo', 'bar', Symbol(baz), Symbol(bing)] 实例：使用Proxy实现观察者模式12345678910111213const person = observable(&#123; name: '张三', age: 20&#125;)function print () &#123; console.log(`$&#123;person.name&#125;, $&#123;person.age&#125;`)&#125;observe(print)person.name = '李四'// 输出// 李四，20 使用Proxy实现12345678910const queuedObservers = new Set()const observe = fn =&gt; queuedObservers.add(fn)const observable = obj =&gt; new Proxy(obj, &#123;set&#125;)function set (target, key, value, receiver) &#123; const result = Reflect.set(target, key, value, receiver) queuedObservers.forEach(observer =&gt; observer()) return result&#125; 先定义一个Set集合，所有观察者函数放进集合。然后observable函数返回原始对象的代理，拦截赋值操作。拦截函数set会自动执行所有观察者]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Proxy实例的方法]]></title>
    <url>%2F2019%2F04%2F02%2FProxy%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Proxy 实例的方法get() get() 用于拦截某个属性的读取操作12345678910111213141516var person = &#123; name: "张三"&#125;var proxy = new Proxy (person, &#123; get: function (target, property) &#123; if (property in target) &#123; return target[property] &#125; else &#123; throw new ReferenceError("Property \"" + property + "\" does not exist.") &#125; &#125;&#125;)proxy.name // '张三'proxy.age // ReferenceError: Property "age" does not exist. get()可以继承123456789let proto = new Proxy (&#123;&#125;, &#123; get (target, propertyKey, receiver) &#123; console.log('GET ' + propertyKey) return target[propertyKey] &#125;&#125;)let obj = Object.create(proto)obj.xxx // "GET xxx" get() 拦截实现数组读取负数索引1234567891011121314151617function createArray (...elements) &#123; let handler = &#123; get (target, propKey, receiver) &#123; let index = Number(propKey) if (index &lt; 0) &#123; propKey = String(target.length + index) &#125; return Reflect.get(target, propKey, receiver) &#125; &#125; let target = [] target.push(...element) return new Proxy(target, handler)&#125;let arr = createArray('a', 'b', 'c')arr[-1] // 'c' Proxy 可以将get()转变为执行某个函数，从而实现属性的链式操作1234567891011121314151617181920212223var pipe = (function () &#123; return function (value) &#123; var funcStack = [] var oproxy = new Proxy(&#123;&#125;, &#123; get: function (pipeObject, fnName) &#123; if (fnName === 'get') &#123; return funcStack.reduce(function (val, fn) &#123; return fn(val) &#125;, value) &#125; funcStack.push(window[fnName]) return oproxy &#125; &#125;) return oproxy &#125;&#125;())var double = n =&gt; n * 2var pow = n =&gt; n * nvar reverseInt = n =&gt; n.toString().split("").reverse().join("") | 0pipe(3).double.pow.reverseInt.get // 63 get() 拦截实现一个生成各种DOM节点的通用函数dom123456789101112131415161718192021222324252627282930const dom = new Proxy(&#123;&#125;, &#123; get (target, property) &#123; return function (attrs = &#123;&#125;, ...children) &#123; const el = document.createElement(property) for (let prop of Object.keys(attrs)) &#123; el.setAttribute(prop, attrs[prop]) &#125; for (let child of childeren) &#123; if (typeof child === 'string') &#123; child = document.creaetTextNode(child) &#125; el.appendChild(child) &#125; return el &#125; &#125;&#125;)const el = dom.div(&#123;&#125;, 'Hello, my name is ', dom.a(&#123;href: '//example.com'&#125;, 'Mark'), '.I like:', dom.ul(&#123;&#125;, dom.li(&#123;&#125;, 'The web'), dom.li(&#123;&#125;, 'Food'), dom.li(&#123;&#125;, '...actually that\'s it') ))document.body.appendChild(el) 如果一个属性不可配置或不可写，则该属性不能被代理，通过Proxy对象访问该属性会报错12345678910111213141516const target = Object.defineProperties(&#123;&#125;, &#123; foo: &#123; value: 123, writable: false, configurable: false &#125;&#125;)const handler = &#123; get (target, propKey) &#123; return 'abc' &#125;&#125;const proxy = new Proxy(target, handler)proxy.foo // TypeError: Invariant check failed set() set() 用于拦截某个属性的复制操作12345678910111213141516171819let validator = &#123; set: function (obj, prop, value) &#123; if (prop === 'age') &#123; if (!Number.isInteger(value)) &#123; throw new TypeError('The age is not an integer') &#125; if (value &gt; 200) &#123; throw new RangeError('The age seems invalid') &#125; &#125; obj[prop] = value &#125;&#125;let person = new Proxy(&#123;&#125;, validator)person.age = 100person.age // 100person.age = 'young' // 报错person.age = 300 // 报错 结合get()、set()，可以做到属性名第一个字符下划线开头的内部属性不背外部读/写12345678910111213141516171819202122var handler = &#123; get (target, key) &#123; invariant (key, 'get') return target[key] &#125;, set (target, key, value) &#123; invariant (key, 'set') target[key] = value return true &#125;&#125;function invariant (key, action) &#123; if (key[0] === '_') &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private "$&#123;key&#125;" property`) &#125;&#125;var target = &#123;&#125;var proxy = new Proxy(target, handler)proxy._prop // Error: Invalid attempt to get private "_prop" propertyproxy._prop = 'c' // Error: Invalid attempt to set private "_prop" property apply() apply() 拦截函数的调用、call和apply操作apply() 接收三个参数：目标对象，目标对象的上下文对象(this)和目标对象的参数数组1234567891011var target = function () &#123; return 'I am the target'&#125;var handler = &#123; apply: function () &#123; return 'I am the proxy' &#125;&#125;var p = new Proxy(target, handler)p() // I am the proxy p 实例作为函数调用时(p())就会被apply方法拦截，返回一个字符串 1234567891011121314var twice = &#123; apply (target, ctx, args) &#123; return Reflect.apply(...arguments) * 2 &#125;&#125;function sum (left, right) &#123; return left + right&#125;var proxy = new Proxy(sum, twice)proxy(1, 2) // 6proxy.call(null, 5, 6) // 22proxy.apply(null, [7, 8]) // 30Reflect.apply(proxy, null, [9, 10]) // 38 每次执行proxy函数(直接调用或call和apply调用)就会被apply()拦截，直接调用Reflect.apply方法也会被拦截 has() has()用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。 has()隐藏某些属性，使其不背in运算符发现1234567891011var handler = &#123; has (target, key) &#123; if (key[0] === '_') &#123; return false &#125; return key in target &#125;&#125;var target = &#123; _prop: 'foo', prop: 'foo'&#125;var proxy = new Proxy(target, handler)'_prop' in proxy // false 如果原对象不可配置或者禁止扩展，这时has拦截会报错12345678910var obj = &#123;a: 10&#125;Object.preventExtensions(obj)var p = new Proxy(obj, &#123; has: function(target, prop) &#123; return false &#125;&#125;)'a' in p // TypeError is thrown has拦截对 for…in 循环不生效12345678910111213141516171819202122232425let stu1 = &#123;name: '张三', score: 59&#125;let stu2 = &#123;name: '李四', score: 99&#125;let handler = &#123; has (target, prop) &#123; if (prop === 'score' &amp;&amp; target[prop] &lt; 60) &#123; console.log(`$&#123;target.name&#125; 不及格`) return false &#125; return prop in target &#125;&#125;let oproxy1 = new Proxy(stu1, handler)let oproxy2 = new Proxy(stu2, handler)'score' in oproxy1 // 张三不及格 false'score' in oproxy2 // truefor (let a in oproxy1) &#123; console.log(oproxy1[a])&#125; // 张三 59for (let b in oproxy2) &#123; console.log(oproxy2[b])&#125; // 李四 99 construct() construct() 用于拦截new命令12345var handler = &#123; construct (target, args, newTarget) &#123; return new target(...args) &#125;&#125; construct()接收两个参数 target: 目标对象 args: 构建函数的参数对象12345678var p = new Proxy(function () &#123;&#125;, &#123; construct: function (target, args) &#123; console.log('called: ' + args.join(',')) return &#123;value: args[0] * 10&#125; &#125;&#125;)(new p(1)).value // "called: 1" 10 construct() 必须返回对象，否则报错1234567var p = new Proxy(function () &#123;&#125;, &#123; construct: function (target, argumentsList) &#123; return 1 &#125;&#125;)new p() // 报错 deleteProperty() deleteProperty() 用于拦截delete操作，如果抛出错误或返回false，则当前属性无法被delete命令删除123456789101112131415var handler = &#123; deleteProperty (target, key) &#123; invariant(key, 'delete') return true &#125;&#125;function invariant (key, action) &#123; if (key[0] === '_') &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private "$&#123;key&#125;" property`) &#125;&#125;var target = &#123;_prop: 'foo'&#125;var proxy = new Proxy(target, handler)delete proxy._prop // Error: Invalid attempt to delete private "_prop" property defineProperty() defineProperty() 拦截了Object.defineProperty操作1234567var handler = &#125;defineProperty (target, key, descriptor) &#123; return false&#125;var target = &#123;&#125;var proxy = new Proxy(target, handler)proxy.foo = 'bar' // TypeError: proxy defineProperty handler returned false for property '"foo"' getOwnPropertyDescriptor() getOwnPropertyDescriptor()拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或undefined1234567891011121314var handler = &#123; getOwnPropertyDescriptor (target, key) &#123; if (key[0] === '_') &#123; return &#125; return Object.getOwnPropertyDescriptor(target, key) &#125;&#125;var target = &#123;_foo: 'bar', baz: 'tar'&#125;var proxy = new Proxy(target, handler)Object.getOwnPropertyDescriptor(proxy, 'wat') // undefinedObject.getOwnPropertyDescriptor(proxy, '_foo') // undefinedObject.getOwnPropertyDescriptor(proxy, 'baz') // &#123;value: 'tar', writeable: true, enumerable: true, configurable: true&#125; getPrototypeOf() getPrototypeOf() 用于拦截获取对象原型 Object.prototype.__proto__ Object.prototype.isPrototypeOf() Object.getPrototypeOf() Reflect.getPrototypeOf() instanceof 12345678var proto = &#123;&#125;var p = new Proxy(&#123;&#125;, &#123; getPrototypeOf (target) &#123; return proto &#125;&#125;)Object.getPrototypeOf(p) === proto // true getPrototypeOf() 拦截Object.getPrototypeOf(),返回proto对象 isExtensible() isExtensible() 拦截Object.isExtensible操作 12345678var p = new Proxy(&#123;&#125;, &#123; isExtensible: function (target) &#123; console.log("called") return true &#125;&#125;)Object.isExtensible(p) // "called" true 该方法返回值必须与目标对象的IsExtensible属性保持一致，否则抛出错误 123456var p = new Proxy(&#123;&#125;, &#123; isExtensible: function(target) &#123; return false &#125;&#125;)Object.isExtensible(p) // 报错 ownKeys() preventExtensions() setPrototypeOf()]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Set和Map数据结构]]></title>
    <url>%2F2019%2F04%2F01%2FSet%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Set基本用法Set, 类似于数组，但是成员值唯一，没有重复 12345678const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x))for (let i of s) &#123; console.log(i)&#125;// 2 3 5 4 向Set加入值时不会发生类型转换，所以 5 和 ” 5 ” 是两个不同的值。 Set 内部判断两个值是否相同时使用的算法叫作 “ Same-value equality飞它类似于精确相等运算符（＝＝＝），主要的区别是 NaN 等于自身，而精确相等运算符认为 NaN 不等于自身。 123456let set = new Set()let a = NaNlet b = NaNset.add(a)set.add(b)set // Set &#123;NaN&#125; 两个对象总是不相等的12345let set = new Set()set.add(&#123;&#125;)set.size // 1set.add(&#123;&#125;)set.size // 2 Set实例的属性和方法 Set.prototype.constructor: 构造函数，默认为Set函数 Set.prototype.size: 返回Set实例的成员总数 操作方法 add(value): 添加某个值，返回Set结构本身 delete(value): 删除某个值，返回布尔值 has(value): 返回布尔值 clear(value): 清除所有成员，无返回值 123456789s.add(1).add(2).add(3)s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2)s.has(2) // false 数组去重12345function dedupe(array) &#123; return Array.from(new Set(array))&#125;dedupe([1, 1, 2, 2, 3]) // [1,2,3] 遍历操作 keys(): 返回键名的遍历器 values(): 返回键值的遍历器 entries(): 返回键值对的遍历器 forEach(): 使用回调函数遍历每个成员 1234567891011121314let set = new Set(['red', 'green', 'blue'])for (let item of set.keys()) &#123; console.log(item) // red green blue&#125;for (let item of set.values()) &#123; console.log(item) // red green blue&#125;for (let item of set.keys()) &#123; console.log(item) // ["red","red"]["green","green"]["blue","blue"]&#125;let set = new Set([1, 2, 3])set.forEach((value, key) =&gt; console.log(value * 2)) // 2 4 6 WeakSet含义WeakSet结构类似于Set，同样是不重复值的集合。 不同的是： WeakSet成员只能是对象，不能是其他类型的值 WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用。 语法const ws = new WeakSet() 123const a = [[1, 2], [3, 4]]const ws = new WeakSet(a)// WeakSet &#123;[1, 2], [3, 4]&#125; WeakSet 结构有以下三个方法 WeakSet.prototype.add(value): 添加新成员 WeakSet.prototype.delete(value): 删除.. WeakSet.prototype.has(value): 返回布尔值 Map含义和基本用法ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值都可以当做键。123456789const m = new Map()const o = &#123;p: 'Hello World'&#125;m.set(o, 'content')m.get(o) // "content"m.has(o) // truem.delete(o) // truem.has(o) // false 12345678910const map = new Map([ ['name', '张三'], ['title', 'Author']])map.size // 2map.has('name') // truemap.get('name') // "张三"map.has('title') // truemap.get('title') // "Author" 如果对同一个键多次赋值，后面的值将覆盖前面的值 1234const map = new Map()map.set(1, 'aaa').set(1, 'bbb')map.get(1) // 'bbb' Map的键实际上和内存地址绑定，只要内存地址不同，就位不同的键 如果Map的键是一个简单类型的值，则只要两个值严格相等， Map就将其视为一个键。包括 +0、-0 和 NaN1234567891011121314let map = new Map()map.set(-0, 123)map.get(+0) // 123map.set(true, 1)map.set('true', 2)map.get(true) // 1map.set(undefined, 3)map.set(null, 4)map.get(undefined) // 3map.set(NaN, 123)map.get(NaN) // 123 实例的属性和操作方法 size 属性12345const map = new Map()map.set('foo', true)map.set('bar', false)map.size // 2 set(key, value) 看前面 get(key) 看前面 has(key) 看前面 delete(key) 看前面 clear() clear方法清除所有成员，无返回1234567let map = new Map()map.set('foo', true)map.set('bar', false)map.size // 2map.clear()map.size // 0 遍历方法 keys() …键名 values() …键值 entries() …所有成员 forEach() …遍历Map Map 遍历顺序就是插入顺序 与其他数据结构互相转换 Map –&gt; Array 使用扩展运算符(…)123const myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc'])[...myMap] // [[true, 7], [&#123;foo: 3&#125;, ['abc']]] Array –&gt; Map 将数组传入Map构造函数即可12345678new Map([ [true, 7], [&#123;foo: 3&#125;, ['abc']]])// Map &#123;// true =&gt; 7,// Object &#123;foo: 3&#125; =&gt; ['abc']//&#125; Map –&gt; 对象 如果Map所有键都是字符串，则可以转为对象12345678910111213function strMapToObj(strMap) &#123; let obj = Object.create(null) for (let [k, v] of strMap) &#123; obj[k] = v &#125; return obj&#125;const myMap = new Map() .set('yes', true) .set('no', false)strMapToObj(myMap) // &#123;yes: true, no: false&#125; 对象 –&gt; Map 123456789function objToStrMap(obj) &#123; let strMap = new Map() for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]) &#125; return strMap&#125;objToStrMap(&#123;yes: true, no: false&#125;) // Map &#123;"yes" =&gt; true, "no" =&gt; false&#125; Map –&gt; JSON Map键名都为字符串 –&gt; 对象JSON1234567function strMapToJson(strMap) &#123; return JSon.stringify(strMapToObj(strMap))&#125;let myMap = new Map().set('yes', true),set('no', false)strMapToJson(myMap) // '&#123;"yes": true, "no", false&#125;' Map键名有非字符串 –&gt; 数组JSON1234567function mapToArrayJson(map) &#123; return JSON.stringify([...map])&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc'])mapToArrayJson(myMap) // '[[true, 7], [&#123;"foo": 3&#125;, ["abc"]]]' JSON –&gt; Map 正常情况所有键名都为字符串 12345function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr))&#125;jsonToStrMap('&#123;"yes": true, "no", false&#125;') // Map &#123;'yes' =&gt; true, 'no', false&#125; 整个JSON为一个数组，且每个数组成员本身又是一个具有两个成员的数组。这时，它可以一一对应的转为Map。这是数组转JSON的逆操作12345function jsonToMap(jsonStr) &#123; return new Map(JSON.parse(jsonStr))&#125;jsonToMap('[[true, 7], [&#123;"foo": 3&#125;, ["abc"]]]') // Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; ['abc']&#125; WeakMap含义WeakMap类似于Map，也用于生成键值对的集合。不同的是： WeakMap 只接受对象作为键名(null除外),不接受其他类型的值作为键名 1234567const map= new WeakMap()map.set(1, 2)// TypeError : 1 is not aηobject!map.set(Symbol(), 2)// TypeError: Invalid value used as weak map keymap.set(null, 2)// TypeError: Invalid value used as weak map key WeakMap的键名所指向的对象不计入垃圾回收机制 WeakMap弱引用只是键名而不是键值，键值依然正常引用 WeakMap 的语法WeakMap没有遍历操作(key()、values()、entries())，也没有size属性。只有4个方法:(get()、set()、has()、delete())]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸡的Leecode学习-day04]]></title>
    <url>%2F2019%2F03%2F20%2F%E8%8F%9C%E9%B8%A1%E7%9A%84Leecode%E5%AD%A6%E4%B9%A0-day04%2F</url>
    <content type="text"><![CDATA[报数报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 1. 1 2. 11 3. 21 4. 1211 5. 111221 1 被读作&quot;one 1&quot; (&quot;一个一&quot;),即11。11 被读作&quot;two 1s&quot;(&quot;两个一&quot;),即 21。21 被读作&quot;one 2&quot;,&quot;one 1&quot;`“一个二”,“一个一”),即1211`。 给定一个正整数 n(1 ≤ n ≤ 30)，输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 示例 1: 输入: 1 输出: &quot;1&quot; 示例 2: 输入: 4 输出: &quot;1211&quot; 先分析题目，这题一开始我是一脸懵逼的，后来仔细看了看，主要就是第n行的数字是第n-1行的内容，然后递归 提交时间 状态 执行用时 内存消耗 语言 7 小时前 通过 136 ms 35.5 MB javascript 1234567891011121314151617181920/** * @param &#123;number&#125; n * @return &#123;string&#125; */var countAndSay = function(n) &#123; var res = '1' for (var i = 1; i &lt; n; i++) &#123; var count = 1, str = '' for (var j = 0; j &lt; res.length; j++) &#123; if (res[j] == res[j + 1]) &#123; count++ &#125; else &#123; str += count + res[j] count = 1 &#125; &#125; res = str &#125; return res&#125;; 令初值为1，然后开始迭代n，依此获取每项的结果 当n = 3时 i = 1, str = ‘11’,count = 1i = 2, res[0] == res[1],count = 2i = 2, str = ‘21’,count = 1, res = ‘21’ 最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 提交时间 状态 执行用时 内存消耗 语言 7 小时前 通过 164 ms 35.4 MB javascript 分析，对于最大和的连续子数组，从首位开始相加，小于0则使用新的子数组 12345678910111213141516/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var maxSubArray = function(nums) &#123; var res = nums[0], sum = 0 for (var i of nums) &#123; if (res &gt; 0) &#123; sum += i &#125; else &#123; sum = i &#125; res = Math.max(res, i) &#125; return res&#125;; 初始令res = nums[0],开始遍历，大于0则相加，小于则使用新的子数组，使用Math.max()用以获取新初值 最后一个单词的长度给定一个仅包含大小写字母和空格&#39; &#39;的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例: 输入: &quot;Hello World&quot; 输出: 5 提交时间 状态 执行用时 内存消耗 语言 7 小时前 通过 128 ms 33.7 MB javascript 分析，很简单的一道题，为了防止字符串左右的空格，先使用trim()，之后使用split(&#39; &#39;)，将单词分隔开，获取最后一个即可 1234567891011/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLastWord = function(s) &#123; var str = s.trim().split(' ') if (str.length == 0) &#123; return 0 &#125; return str[str.length - 1].length&#125;; 加一给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例 2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。 提交时间 状态 执行用时 内存消耗 语言 6 小时前 通过 144 ms 33.5 MB javascript 分析，存在两种情况，一种是有9，则有进位，一种正常加一就行 123456789101112131415161718/** * @param &#123;number[]&#125; digits * @return &#123;number[]&#125; */var plusOne = function(digits) &#123; for (var i = digits.length - 1; i &gt;= 0; i--) &#123; if (digits[i] == 9) &#123; digits[i] = 0 &#125; else &#123; digits[i] ++ return digits &#125; &#125; if (i == -1) &#123; digits.unshift(1) &#125; return digits&#125;; 逆序遍历数组，为9则置为0，之后在前一位++，如果不在else处返回则有进位，此时i==-1，使用unshift首位+1 二进制求和给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字1和0。 示例 1: 输入: a = &quot;11&quot;, b = &quot;1&quot; 输出: &quot;100&quot; 示例 2: 输入: a = &quot;1010&quot;, b = &quot;1011&quot; 输出: &quot;10101&quot; 提交时间 状态 执行用时 内存消耗 语言 5 小时前 通过 144 ms 35.2 MB javascript 分析，偷鸡做法，使用parseInt，存在数值范围，超出则gg 123var addBinary = function(a, b) &#123; return (parseInt(a, 2) + parseInt(b, 2)).toString(2)&#125; 123456789101112131415161718192021222324252627282930/** * @param &#123;string&#125; a * @param &#123;string&#125; b * @return &#123;string&#125; */var addBinary = function(a, b) &#123; var len = a.length &gt; b.length ? a.length : b.length, res = [], carry = 0 var a = a.split('').reverse(), b = b.split('').reverse() for (var i = 0; i &lt; len; i++) &#123; var sum = +(a[i] || 0) + +(b[i] || 0) + carry if (sum == 0) &#123; res[i] = 0 carry = 0 &#125; else if (sum == 1) &#123; res[i] = 1 carry = 0 &#125; else if (sum == 2) &#123; res[i] = 0 carry = 1 &#125; else &#123; res[i] = 1 carry = 1 &#125; &#125; if (carry == 1) &#123; res.push(1) &#125; return res.reverse().join('')&#125;; 定义len取字符串最长长度，然后翻转字符串，定义carry作为进位值，由值来决定结果和进位。+指类型转换，不能转换则置0. 最终有进位则 push(1),然后翻转字符串。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Leecode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸡的Leecode学习-day03]]></title>
    <url>%2F2019%2F03%2F18%2F%E8%8F%9C%E9%B8%A1%E7%9A%84Leecode%E5%AD%A6%E4%B9%A0-day03%2F</url>
    <content type="text"><![CDATA[删除排序数组中的重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 提交时间 状态 执行用时 内存消耗 语言 4 天前 解答错误 N/A N/A javascript 4 天前 通过 192 ms 36.8 MB javascript 解答错误： 提交记录 输入： [1,1,2] 输出： [1,0,1,2] 预期： [1,2] 12345678910111213141516/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; var len = 1 var index = nums[0] for (var i in nums) &#123; if (i != index) &#123; nums[len++] = i index = i &#125; &#125; return len&#125;; for (var i in nums) 使用了in遍历所以出错了 for in是ES5标准，遍历key. for of是ES6标准，遍历value. 正确提交：12345678910111213141516/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; var len = 1 var index = nums[0] for (var i of nums) &#123; if (i != index) &#123; nums[len++] = i index = i &#125; &#125; return len&#125;; 有效的括号给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1: 输入: &quot;()&quot; 输出: true 示例 2: 输入: &quot;()[]{}&quot; 输出: true 示例 3: 输入: &quot;(]&quot; 输出: false 示例 4: 输入: &quot;([)]&quot; 输出: false 示例 5: 输入: &quot;{[]}&quot; 输出: true 提交时间 状态 执行用时 内存消耗 语言 3 天前 通过 124 ms 33.5 MB javascript 12345678910111213141516171819/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function(s) &#123; var list = [] for (var i = 0; i &lt; s.length; i++) &#123; if (s[i] == '(') &#123; list.push(')') &#125; else if (s[i] == '[') &#123; list.push(']') &#125; else if (s[i] == '&#123;') &#123; list.push('&#125;') &#125; else if (list.pop() != s[i]) &#123; return false &#125; &#125; return !list.length&#125;; 用栈来做，为左括号则入栈，右括号出栈，出栈顺序有问题则返回false。 移除元素给定一个数组nums和一个值val，你需要原地移除所有数值等于val的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 怎么说呢，感觉和前面删除排序数组中的重复项类似吧 提交时间 状态 执行用时 内存消耗 语言 3 天前 通过 108 ms 33.8 MB javascript 3 天前 解答错误 N/A N/A javascript 错误提交： 提交记录 输入： [0,1,2,2,3,0,4,2]2 输出： [0,1,0,3,0] 预期： [0,1,4,0,3] 123456789101112131415/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; val * @return &#123;number&#125; */var removeElement = function(nums, val) &#123; var len = 0 for (var i of nums) &#123; if (nums[i] != val) &#123; nums[len++] = nums[i] &#125; &#125; return len&#125;; 没仔细想感觉和前面题类似 顺便不正常了那么一会瞎写了for of，一脸懵逼的nums[i]。。。。 正确提交： 123456789101112131415161718/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; val * @return &#123;number&#125; */var removeElement = function(nums, val) &#123; var len = 0 if (nums == null || nums.length == 0) &#123; return 0 &#125; for (var i of nums) &#123; if (i != val) &#123; nums[len] = i len++ &#125; &#125; return len&#125;; 在数组不为0的情况下，遍历。。。。。。。 然后存进去就是了。 实现strStr()实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot; 输出: 2 示例 2: 输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot; 输出: -1 说明: 当needle是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当needle是空字符串时我们应当返回 0 。这与C语言的strstr()以及 Java的 indexOf()定义相符。 提交时间 状态 执行用时 内存消耗 语言 3 天前 通过 124 ms 33.4 MB javascript 1234567891011/** * @param &#123;string&#125; haystack * @param &#123;string&#125; needle * @return &#123;number&#125; */var strStr = function(haystack, needle) &#123; if (needle == '') &#123; return 0 &#125; return haystack.indexOf(needle)&#125;; 代码emmm 就当不存在吧。 如果考kmp算法 分类简单就2333 不考吧 内置函数emmm 溜了溜了~~~ 搜索插入位置给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0 提交时间 状态 执行用时 内存消耗 语言 3 天前 通过 116 ms 33.6 MB javascript 1234567891011121314/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number&#125; */var searchInsert = function(nums, target) &#123; for (var i = 0; i &lt; nums.length; i++) &#123; if (target &lt;= nums[i]) &#123; return i &#125; else if (target &gt; nums[nums.length - 1]) &#123; return nums.length &#125; &#125;&#125;; 感觉是我碰到的最简单的一道题了。。 当然数据多了还是二分查找快。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Leecode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸡的Leecode学习-day02]]></title>
    <url>%2F2019%2F03%2F17%2F%E8%8F%9C%E9%B8%A1%E7%9A%84Leecode%E5%AD%A6%E4%B9%A0-day02%2F</url>
    <content type="text"><![CDATA[一周前做的了，今天刚好有空写到blog里，以后尽量每天一次吧 只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入：[2,2,1] 输出：1 示例 2: 输入: [4,1,2,1,2] 输出: 4 提交时间 状态 执行用时 内存消耗 语言 10 天前 通过 156 ms 35.2 MB javascript 12345678910/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var singleNumber = function(nums) &#123; for(var i = 1; i &lt; nums.length; i++)&#123; nums[0] = nums[0] ^ nums[i] &#125; return nums[0]&#125;; 其余元素均出现两次，只有所求元素一次，所以异或即可 求众数给定一个大小为n的数组，找到其中的众数。众数是指在数组中出现次数大于[n/2]的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3] 输出: 3 示例 2: 输入: [2,2,1,1,1,2,2] 输出: 2 提交时间 状态 执行用时 内存消耗 语言 10 天前 通过 108 ms 38.2 MB javascript 123456789101112131415161718/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var majorityElement = function(nums) &#123; var res = 0, count = 0 for (var num of nums)&#123; if (count === 0) &#123; res = num count++ &#125; else if (res === num) &#123; count++ &#125; else &#123; count-- &#125; &#125; return res&#125;; 先假设res为第一个数，开始遍历，相同+1,不同-1,如果count===0，res下一个数继续，最终可获得结果。 搜索二维矩阵编写一个高效的算法来搜索mxn矩阵matrix中的一个目标值target。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回true。 给定 target = 20，返回false。 提交时间 状态 执行用时 内存消耗 语言 10 天前 通过 180 ms 37.3 MB javascript 10 天前 执行出错 N/A N/A javascript 10 天前 执行出错 N/A N/A javascript 10 天前 通过 768 ms 37 MB javascript 执行用时768ms1234567891011121314/** * @param &#123;number[][]&#125; matrix * @param &#123;number&#125; target * @return &#123;boolean&#125; */var searchMatrix = function(matrix, target) &#123; for(let i = 0; i &lt; matrix.length; i++) &#123; for (let j = 0; j &lt; matrix[0].length; j++)&#123; if(matrix[i][j] === target)&#123; return true &#125; &#125; &#125;return false&#125;; 感觉应该很无脑了2333，直接遍历所有。 执行用时180ms1234567891011121314151617181920212223/** * @param &#123;number[][]&#125; matrix * @param &#123;number&#125; target * @return &#123;boolean&#125; */var searchMatrix = function(matrix, target) &#123; if(matrix.length &lt; 1 || matrix.length[0] &lt; 1) &#123; return false &#125; let row = matrix.length, col = matrix[0].length, i = row - 1, j = 0 while(i &gt;= 0 &amp;&amp; j &lt; col) &#123; if (matrix[i][j] &gt; target) &#123; i-- &#125; else if (matrix[i][j] &lt; target) &#123; j++ &#125; else if (matrix[i][j] === target)&#123; return true &#125; else &#123; return false &#125; &#125; return false&#125;; 取矩阵左下角为锚点，其余元素有个特性，在其上的总小于锚点值，右边的总大于锚点值。之后比较大小即可。 合并两个有序数组给定两个有序整数数组nums1和nums2,将nums2合并到nums1中，使得num1成为一个有序数组。 说明: 初始化nums1和nums2的元素数量分别为m和n。你可以假设nums1有足够的空间（空间大小大于或等于 m + n）来保存nums2中的元素。示例: 输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 提交时间 状态 执行用时 内存消耗 语言 10 天前 通过 104 ms 34.6 MB javascript 1234567891011121314/** * @param &#123;number[]&#125; nums1 * @param &#123;number&#125; m * @param &#123;number[]&#125; nums2 * @param &#123;number&#125; n * @return &#123;void&#125; Do not return anything, modify nums1 in-place instead. */var merge = function(nums1, m, nums2, n) &#123; nums1 = nums1.reverse() for (let i = 0; i &lt; nums2.length; i++) &#123; nums1[i] += nums2[i] &#125; nums1 = nums1.sort((a,b) =&gt; &#123;return a - b&#125;)&#125;; 取巧写法~~~ 捂脸···]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Leecode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript继承]]></title>
    <url>%2F2019%2F03%2F09%2FJavaScript%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[接之前的坑，重新复习一遍继承 原型链Js中描述了原型链的概念，并将原型链作为实现继承的主要方法。基本思想便是利用原型让一个引用类型继承另一个引用类型的属性和方法。 实现原型链的基本模式123456789101112131415161718192021function SuperType () &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function () &#123; return this.property;&#125;function SubType () &#123; this.subproperty = false;&#125;// 继承了 SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function () &#123; return this.subproperty;&#125;var instance = new SubType();alert(instance.getSuperValue()); // true SubType继承自SuperType。继承通过创建SuperType的示例，并将该实例赋给SubType.prototype实现。本质为重写原型对象，代之以一个新类型的示例。确立继承之后，再在SubType.prototype添加一个方法，这样就在继承SuperType的属性和方法基础上添加了新方法。 总之，SubType继承SuperType，SuperType继承自Object。当调用instance.toString()时，实际调用的是保存在Object.prototype中的方法。 子类重写超类中的方法或者添加超类不存在的方法时，一定要放在替换原型的语句之后。 存在的问题： 包含引用类型值的原型。 eg.123456789101112131415function SuperType() &#123; this.colors = ["red", "blue", "green"];&#125;function SubType() &#123;&#125;// 继承SubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push("black");alert(instance1.colors); // "red,blue,green,black"var instance2 = new SubType();alert(instance2.colors); // "red,blue,green,black" 结果显而易见，子类的所有实例共享属性。 创建子类型实例时，不能向超类型的构造函数中传递参数。(无法再不影响所有对象实例的情况下，给超类的构造函数传递参数) 实际很少单独使用原型链方法 借用构造函数 借用构造函数(constructor stealing),即(伪造对象或经典继承).通过在子类型构造函数的内部调用超类型构造函数实现。使用apply()和call()`方法。 123456789101112131415function SuperType() &#123; this.colors = ["red", "blue", "green"];&#125;function SubType() &#123; // 继承 SuperType.call(this);&#125;var instance1 = new SubType();instance1.colors.push("black");alert(instance1.colors); // "red,blue,green,black"var instance2 = new SubType();alert(instance2.colors); // "red,blue,green" 上式通过在SubType()实例下调用了SuperType构造函数。 相对于原型链方式的优势 1234567891011121314function SuperType(name) &#123; this.name = name;&#125;function SubType() &#123; // 继承，传递参数 SuperType.call(this, "Nicholas"); // 实例属性 this.age = 29;&#125;var instance = new SubType();alert(instance.name); // Nicholasalert(instace.age); // 29 SuperType()只接受一个参数，在SubType()构造函数中调用会为SubType()实例设置 name属性。在此之后再添加应该在子类型中定义的属性防止SuperType()构造函数重写子类属性。 存在的问题 函数无法复用，超类原型定义的方法子类也不可见，即所有类型只能使用构造函数模式。 因此很少单独使用构造函数方式 组合继承组合继承(combination inheritance),经典伪继承，即将原型链和构造函数方式合用，从而发挥二者之长。 思路是使用原型链实现对原型属性和方法的继承，通过构造函数实现对实例属性的继承。既保证在原型上定义方法实现了函数复用，又保证每个实例都有自己的属性。1234567891011121314151617181920212223242526272829303132function SuperType(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;function SubType(name, age) &#123; // 继承属性 SuperType.call(this, name); this.age = age;&#125;// 继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() &#123; alert(this.age);&#125;var instance1 = new SubType("Nicholas", 29);instance1.colors.push("black");alert(instance1.colors); // "red,blue,green,black"instance1.sayName(); // "Nicholas"instance1.sayAge(); // 29var instance2 = new SubType("Greg", 27);alert(instance2.colors); // "red,blue,green"instance2.sayName(); // "Greg"instance2.sayAge(); // 27 原型式继承 在object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。 1234567891011121314var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"]&#125;;var person1 = object(person);person1.name = "Greg";person1.friends.push("Rob");var person2 = object(person);person2.name = "Linda";person2.friends.push("Barbie");alert(person.friends); // "Shelby,Court,Van,Rob,Barbie 寄生式继承 寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。 1234567function createAnother(original) &#123; var clone = object(original); // 通过调用函数创建一个对象 clone.sayHi = function() &#123; // 以某种方式来增强这个对象 alert("hi"); &#125;; return clone; //返回这个对象&#125; 使用如下1234567var person = &#123; name: 'Nicholas', friends: ["Shelby", "Court", "Van"]&#125;;var person1 = createAnother(person);person1.sayHi(); // "hi" 寄生组合式继承 组合式继承无论什么情况下都会调用两次超类构造函数，一次是创建子类型原型，一次是子类型构造函数内部。 123456789101112131415161718192021function SuperType(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;function SubType(name, age) &#123; // 继承属性 SuperType.call(this, name); // 第二次调用SuperType() this.age = age;&#125;// 继承方法SubType.prototype = new SuperType(); // 第一次调用 SuperType()SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() &#123; alert(this.age);&#125; 第一次调用时SubType.prototype得到两个属性:name、colors(此时位于SubType原型).第二次调用SubType时在新对象上创建了实例属性name和colors。新创建的属性屏蔽了原型中的同名属性。 寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。 基本思路：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已 本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。 eg.12345function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); // 创建对象 prototype.constructor = subType; // 增强对象 subType.prototype = prototype; // 指定对象&#125; 上式inheritPrototype()接收两个参数：子类构造函数和超类构造函数。 在函数内部： 创建超类原型的副本 为创建的副本添加constructor属性，弥补因重写原型失去的默认constructor属性 将新创建的对象赋值给子类型的原型。 12345678910111213141516171819function SuperType(name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function() &#123; alert(this.age);&#125; 这个例子的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了在SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用instanceof和isPrototypeOf()。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript引用类型的Array类型]]></title>
    <url>%2F2019%2F03%2F04%2FJavaScript%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84Array%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[鄙渣学了一学期的JavaScript，无奈并没有学通，最终还是祭出了Js红宝书，从头预习 转换方法所有对象都具有 toLocaleString()、toString()和valueOf()方法。 12345678910111213141516171819var person1 = &#123; toLocaleString : function () &#123; return "Nikolaos"; &#125;, toString : function() &#123; return "Nikolaos"; &#125;&#125;;var person2 = &#123; toLocaleString : function () &#123; return "Grigorios"; &#125;, toString : function () &#123; return "Greg"; &#125;&#125;; 1234var people = [person1, person2];alert(people); // Nicholas,Gregalert(people.toString()); // Nicholas,Gregalert(people.toLocaleString()); // Nicholas,Grigorios RT,默认调用的是toString()同下一行显式调用。 eg:可以使用join()更改字符串的分隔方式12var colors = ["red", "green", "blue"];alert(colors.join("|")); // red|green|blue 栈方法栈即是需要后进先出的，Js也为此提供了push()和pop()方法用以实现栈的LIFO(Last-In-First-Out)。 123456789101112var colors = new Array();var count = colors.push("red", "green");alert(count); // 2alert(colors); // red,greencount = colors.push("black");alert(count); // 3alert(colors); // red,green,blackvar item = colors.pop();alert(item); // "black"alert(colors.length); // 2 队列方法队列的访问方式是FIFO(First-In-First-Out)，Js也有相应的shift()和unshift()方法。 12345678910111213var colors = new Array();var count = colors.push("red", "green");alert(count); // 2alert(colors); // red,greencount = colors.push("black");alert(count); // 3alert(colors); // red,green,blackvar item = colors.shift();alert(item); // "red"alert(colors.length); // 2alert(colors); // green, black unshift()用以在数组前段添加任意个项并返回新数组长度。 重排序方法reverse()和sort(). 123var values = [1, 2, 3, 4, 5];values.reverse();alert(values); // 5, 4, 3, 2, 1 sort()的弊端.123var values = [0, 1, 5, 10, 15];values.sort();alert(values); // 0, 1, 10, 15, 5 改进方式123456789101112131415function compare(value1, value2)&#123; if (value1 &lt; value2)&#123; return -1; &#125; else if(value1 &gt; value2)&#123; return 1; &#125; else&#123; return 0; &#125;&#125;var values = [0, 1, 5, 10, 15];values.sort(compare);alert(values); // 0, 1, 5, 10, 15 操作方法concat().创建当前数组的副本，并将接收到的参数添加到副本的末尾，并返回新的数组。12345var colors = ["red", "green", "blue"];var colors2 = colors.concat("yellow", ["black", "brown"]);alert(colors); // red,green,bluealert(colors2); // red,green,blue,yellow,black,brown slice().基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。 123456var colors = ["red", "green", "blue", "yellow", "purple"];var colors2 = colors.slice(1);var colors3 = colors.slice(1, 4);alert(colors2); // green,blue,yellow,purplealert(colors3); // green,blue,yellow splice().有如下三种方法 删除: 指定2个参数，要删除的第一项的位置和要删除的项数。 插入: 指定3个参数，起始位置、0(要删除的项数)和要插入的项。 替换: 指定3个参数，起始位置、要删除的项数和要插入任意数量的项。 123456789101112var colors = ["red", "green", "blue"];var removed = colors.splice(0,1); // 删除第一项alert(colors); // green,bluealert(removed); // red，返回的数组中只包含一项removed = colors.splice(1, 0, "yellow", "orange"); // 从位置1开始插入两项alert(colors); // green,yellow,orange,bluealert(removed); // 返回的是一个空数组removed = colors.splice(1, 1, "red", "purple"); // 插入两项，删除一项alert(colors); // green,red,purple,orange,bluealert(removed); // yellow，返回的数组中只包含一项 位置方法indexOf()和lastIndexOf().均接收两个参数：要查找的项和(可选)查找起点位置的索引。 123456789101112131415var numbers = [1,2,3,4,5,4,3,2,1];alert(numbers.indexOf(4)); //3alert(numbers.lastIndexOf(4)); //5alert(numbers.indexOf(4, 4)); //5alert(numbers.lastIndexOf(4, 4)); //3var person = &#123; name: "Nicholas" &#125;;var people = [&#123; name: "Nicholas" &#125;];var morePeople = [person];alert(people.indexOf(person)); //-1alert(morePeople.indexOf(person)); //0 迭代方法 every():对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回true。 filter():对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。 forEach():对数组中的每一项运行给定函数，无返回值。 map():对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some():对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。 1234567var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(everyResult); //false 1234567var numbers = [1,2,3,4,5,4,3,2,1];var filterResult = numbers.filter(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(filterResult); // [3, 4, 5, 4, 3] 1234567var numbers = [1,2,3,4,5,4,3,2,1];var mapResult = numbers.map(function(item, index, array)&#123; return item * 2;&#125;);alert(mapResult); // [2, 4, 6, 8, 10, 8, 6, 4, 2] 123456var numbers = [1,2,3,4,5,4,3,2,1];numbers.forEach(function(item, index, array)&#123; //执行操作 // forEach 本质上等同于使用for循环&#125;) 1234567var numbers = [1,2,3,4,5,4,3,2,1];var someResult = numbers.some(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(someResult); //true 归并方法 reduce():迭代数组所有项，从左向右。 reduceRight():迭代数组所有项，从右向左。 1234567var values = [1, 2, 3, 4, 5];var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum); // 15 初次执行，prev = 1, cur = 2 第二次执行，prev = 3, cur = 3 持续到遍历所有项 reduceRight()同理。 初次执行，prev = 5, cur = 4 第二次执行，prev = 9, cur = 3 持续到遍历所有项]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸡的Leecode学习-day01]]></title>
    <url>%2F2019%2F02%2F26%2F%E8%8F%9C%E9%B8%A1%E7%9A%84Leecode%E5%AD%A6%E4%B9%A0-day01%2F</url>
    <content type="text"><![CDATA[写在最先 之前博客用的个人域名然后放在vultr上，前阵子不知道怎么出问题了，访问特别困难，后来发现dnspod解析也需要备案，思来想去干脆直接在github上写了，以前那点文章也懒得恢复了！ 最近开始在Leecode上刷题，先从简单的开始，嘿嘿！刚好在博客上也做一番记录，算是让自己记忆更深吧。 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例： 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 提交时间 状态 执行用时 内存消耗 语言 14 天前 通过 52 ms 8.1 MB python3 14 天前 通过 7976 ms 7.3 MB python3 第一次提交的堪堪没有超时，因为是直接双for循环暴力解决的。。。1234567891011121314class Solution: def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if len(nums) &lt; 2: return for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == target: return[i, j] 后来仔细想了想用了dict解决，效率还好。1234567891011121314class Solution: def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ dict = &#123;&#125; for i in range(len(nums)): temp = target - nums[i] if nums[i] in dict: return [dict[nums[i]], i] else: dict[temp] = i 整数反转给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。示例1： 输入: 123 输出: 321 示例2： 输入: -123 输出: -321 示例3： 输入: 120 输出: 21 注意：假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31^, 2^31^ − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 提交时间 状态 执行用时 内存消耗 语言 8 小时前 通过 140 ms 13.3 MB python3 8 小时前 解答错误 N/A N/A python3 8 小时前 执行出错 N/A N/A python3 不得不说还是太粗心大意，一开始都没看到示例2，3，就直接提交，直接执行出错了。 第一次的代码：12345678910class Solution: def reverse(self, x: int) -&gt; int: x = str(x) y = '' for i in x: y = i + y y = int(y) if -2**31&lt;y&lt;2**31-1: return y return 0 提交记录 执行出错信息： Line 7: ValueError: invalid literal for int() with base 10: ‘321-‘ 最后执行的输入： -123 第二次的代码：123456789101112131415class Solution: def reverse(self, x: int) -&gt; int: x1 = str(x) y = '' x = '' if x1[0] == '-': x += '-' for i in x1: y = i + y y = y.rstrip('-') y = x + y y = int(y) if -2**31&lt;y&lt;2**31-1: print(y) return 0 提交记录 输入： 123 输出： 0 预期： 321 最终提交如下，strip方法真的是这次用了才熟悉了。123456789101112131415class Solution: def reverse(self, x: int) -&gt; int: x1 = str(x) y = '' x = '' if x1[0] == '-': x += '-' for i in x1: y = i + y y = y.rstrip('-') y = x + y y = int(y) if -2**31&lt;y&lt;2**31-1: return y return 0 回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 好吧，我想说不能23333，真的是菜鸡本菜了 提交时间 状态 执行用时 内存消耗 语言 8 小时前 通过 276 ms 13.5 MB python3 8 小时前 解答错误 N/A N/A python3 第一次提交代码如下：1234567891011class Solution: def isPalindrome(self, x: int) -&gt; bool: str_x = str(x) y = '' if str_x[0] == '-': return False for i in str_x: y = i + y y = int(y) if x == y: return True 提交记录 输入： 10 输出： null 预期： false 最终结果如下：12345678910111213class Solution: def isPalindrome(self, x: int) -&gt; bool: str_x = str(x) y = '' if str_x[0] == '-': return False for i in str_x: y = i + y y = int(y) if x == y: return True else: return False 罗马数字转整数罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: &quot;III&quot; 输出: 3 示例 2: 输入: &quot;IV&quot; 输出: 4 示例 3: 输入: &quot;IX&quot; 输出: 9 示例 4: 输入: &quot;LVIII&quot; 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5: 输入: &quot;MCMXCIV&quot; 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 这题我一开始真的是， 我枯了emmm，思来想去最后用了n个if解决了。。。。。。 提交时间 状态 执行用时 内存消耗 语言 7 小时前 通过 248 ms 13.4 MB python3 7 小时前 解答错误 N/A N/A python3 本来以为第一次提交就直接ok，没想到出错了。。12345678910111213141516171819202122232425262728293031class Solution: def romanToInt(self, s: str) -&gt; int: dict = &#123;'I': 1,'V': 5,'X': 10, 'L': 50,'C': 100,'D': 500,'M': 1000&#125; sum = 0 if len(s) == 1: return dict[s] for i in range(len(s)): if s[i-1] == 'I': if s[i] == 'V' or s[i] == 'X': sum -= 1 else: sum += 1 if s[i-1] == 'V': sum += 5 if s[i-1] == 'X': if s[i] == 'L' or s[i] == 'C': sum -= 10 else: sum += 10 if s[i-1] == 'L': sum += 50 if s[i-1] == 'C': if s[i] == 'D' or s[i] == 'M': sum -= 100 else: sum += 100 if s[i-1] == 'D': sum += 500 if s[i-1] == 'M': sum += 1000 return sum 提交记录 输入： “MMMCDXC” 输出： 3290 预期： 3490 放debug里面跑了一遍才发现是Python for循环的问题。如下改用while循环后正常了。123456789101112131415161718192021222324252627282930313233343536class Solution: def romanToInt(self, s: str) -&gt; int: dict = &#123;'I': 1,'V': 5,'X': 10, 'L': 50,'C': 100,'D': 500,'M': 1000&#125; sum = 0 i = 0 if len(s) == 1: return dict[s] s = s + ' ' while i &lt; len(s): if i == 0: i += 1 if s[i-1] == 'I': if s[i] == 'V' or s[i] == 'X': sum -= 1 else: sum += 1 if s[i-1] == 'V': sum += 5 if s[i-1] == 'X': if s[i] == 'L' or s[i] == 'C': sum -= 10 else: sum += 10 if s[i-1] == 'L': sum += 50 if s[i-1] == 'C': if s[i] == 'D' or s[i] == 'M': sum -= 100 else: sum += 100 if s[i-1] == 'D': sum += 500 if s[i-1] == 'M': sum += 1000 i += 1 return sum 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] 输出: &quot;fl&quot; 示例 2: 输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;] 输出: &quot;&quot; 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。|提交时间|状态|执行用时|内存消耗|语言||:——:|:——:|:——:|:——:|:——:||7 小时前| 通过 |56 ms |13.2 MB| python3| 这道题我一开始想偏了，一直想着怎么遍历怎么怎么，半天解决不了。最后本菜只能参考官方题解Java版然后用Python写了出来 下面是官方题解12345678910 public String longestCommonPrefix(String[] strs) &#123; if (strs.length == 0) return ""; String prefix = strs[0]; for (int i = 1; i &lt; strs.length; i++) while (strs[i].indexOf(prefix) != 0) &#123; prefix = prefix.substring(0, prefix.length() - 1); if (prefix.isEmpty()) return ""; &#125; return prefix;&#125; 下面是我用Python改了一遍的。(哭~~） Python 没有indexof这里想到了用find替代，然后下面切割字符串刚刚好Python的切片。12345678910111213141516class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: i = 1 if len(strs) == 0: return '' if len(strs) == 1: return strs[0] if len(strs) &gt; 1: temp = strs[0] while i &lt; len(strs): while strs[i].find(temp) != 0: temp = temp[0:len(temp) - 1] if temp == '': return '' i += 1 return temp 慢慢来吧。菜鸡终有出头日]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Leecode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
