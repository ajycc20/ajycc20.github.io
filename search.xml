<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript的Array类型]]></title>
    <url>%2F2019%2F03%2F04%2FJavaScript%E7%9A%84Array%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[鄙渣学了一学期的JavaScript，无奈并没有学通，最终还是祭出了Js红宝书，从头预习 转换方法所有对象都具有 toLocaleString()、toString()和valueOf()方法。 12345678910111213141516171819var person1 = &#123; toLocaleString : function () &#123; return "Nikolaos"; &#125;, toString : function() &#123; return "Nikolaos"; &#125;&#125;;var person2 = &#123; toLocaleString : function () &#123; return "Grigorios"; &#125;, toString : function () &#123; return "Greg"; &#125;&#125;; 1234var people = [person1, person2];alert(people); // Nicholas,Gregalert(people.toString()); // Nicholas,Gregalert(people.toLocaleString()); // Nicholas,Grigorios RT,默认调用的是toString()同下一行显式调用。 eg:可以使用join()更改字符串的分隔方式12var colors = ["red", "green", "blue"];alert(colors.join("|")); // red|green|blue 栈方法栈即是需要后进先出的，Js也为此提供了push()和pop()方法用以实现栈的LIFO(Last-In-First-Out)。 123456789101112var colors = new Array();var count = colors.push("red", "green");alert(count); // 2alert(colors); // red,greencount = colors.push("black");alert(count); // 3alert(colors); // red,green,blackvar item = colors.pop();alert(item); // "black"alert(colors.length); // 2 队列方法队列的访问方式是FIFO(First-In-First-Out)，Js也有相应的shift()和unshift()方法。 12345678910111213var colors = new Array();var count = colors.push("red", "green");alert(count); // 2alert(colors); // red,greencount = colors.push("black");alert(count); // 3alert(colors); // red,green,blackvar item = colors.shift();alert(item); // "red"alert(colors.length); // 2alert(colors); // green, black unshift()用以在数组前段添加任意个项并返回新数组长度。 重排序方法reverse()和sort(). 123var values = [1, 2, 3, 4, 5];values.reverse();alert(values); // 5, 4, 3, 2, 1 sort()的弊端.123var values = [0, 1, 5, 10, 15];values.sort();alert(values); // 0, 1, 10, 15, 5 改进方式123456789101112131415function compare(value1, value2)&#123; if (value1 &lt; value2)&#123; return -1; &#125; else if(value1 &gt; value2)&#123; return 1; &#125; else&#123; return 0; &#125;&#125;var values = [0, 1, 5, 10, 15];values.sort(compare);alert(values); // 0, 1, 5, 10, 15 操作方法concat().创建当前数组的副本，并将接收到的参数添加到副本的末尾，并返回新的数组。12345var colors = ["red", "green", "blue"];var colors2 = colors.concat("yellow", ["black", "brown"]);alert(colors); // red,green,bluealert(colors2); // red,green,blue,yellow,black,brown slice().基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。 123456var colors = ["red", "green", "blue", "yellow", "purple"];var colors2 = colors.slice(1);var colors3 = colors.slice(1, 4);alert(colors2); // green,blue,yellow,purplealert(colors3); // green,blue,yellow splice().有如下三种方法 删除: 指定2个参数，要删除的第一项的位置和要删除的项数。 插入: 指定3个参数，起始位置、0(要删除的项数)和要插入的项。 替换: 指定3个参数，起始位置、要删除的项数和要插入任意数量的项。 123456789101112var colors = ["red", "green", "blue"];var removed = colors.splice(0,1); // 删除第一项alert(colors); // green,bluealert(removed); // red，返回的数组中只包含一项removed = colors.splice(1, 0, "yellow", "orange"); // 从位置1开始插入两项alert(colors); // green,yellow,orange,bluealert(removed); // 返回的是一个空数组removed = colors.splice(1, 1, "red", "purple"); // 插入两项，删除一项alert(colors); // green,red,purple,orange,bluealert(removed); // yellow，返回的数组中只包含一项 位置方法indexOf()和lastIndexOf().均接收两个参数：要查找的项和(可选)查找起点位置的索引。 123456789101112131415var numbers = [1,2,3,4,5,4,3,2,1];alert(numbers.indexOf(4)); //3alert(numbers.lastIndexOf(4)); //5alert(numbers.indexOf(4, 4)); //5alert(numbers.lastIndexOf(4, 4)); //3var person = &#123; name: "Nicholas" &#125;;var people = [&#123; name: "Nicholas" &#125;];var morePeople = [person];alert(people.indexOf(person)); //-1alert(morePeople.indexOf(person)); //0 迭代方法 every():对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回true。 filter():对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。 forEach():对数组中的每一项运行给定函数，无返回值。 map():对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some():对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。 1234567var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(everyResult); //false 1234567var numbers = [1,2,3,4,5,4,3,2,1];var filterResult = numbers.filter(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(filterResult); // [3, 4, 5, 4, 3] 1234567var numbers = [1,2,3,4,5,4,3,2,1];var mapResult = numbers.map(function(item, index, array)&#123; return item * 2;&#125;);alert(mapResult); // [2, 4, 6, 8, 10, 8, 6, 4, 2] 123456var numbers = [1,2,3,4,5,4,3,2,1];numbers.forEach(function(item, index, array)&#123; //执行操作 // forEach 本质上等同于使用for循环&#125;) 1234567var numbers = [1,2,3,4,5,4,3,2,1];var someResult = numbers.some(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(someResult); //true 归并方法 reduce():迭代数组所有项，从左向右。 reduceRight():迭代数组所有项，从右向左。 1234567var values = [1, 2, 3, 4, 5];var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum); // 15 初次执行，prev = 1, cur = 2 第二次执行，prev = 3, cur = 3 持续到遍历所有项 reduceRight()同理。 初次执行，prev = 5, cur = 4 第二次执行，prev = 9, cur = 3 持续到遍历所有项]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸡的Leecode学习(day01)]]></title>
    <url>%2F2019%2F02%2F26%2F%E8%8F%9C%E9%B8%A1%E7%9A%84Leecode%E5%AD%A6%E4%B9%A0(day01)%2F</url>
    <content type="text"><![CDATA[写在最先 之前博客用的个人域名然后放在vultr上，前阵子不知道怎么出问题了，访问特别困难，后来发现dnspod解析也需要备案，思来想去干脆直接在github上写了，以前那点文章也懒得恢复了！ 最近开始在Leecode上刷题，先从简单的开始，嘿嘿！刚好在博客上也做一番记录，算是让自己记忆更深吧。 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例： 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 提交时间 状态 执行用时 内存消耗 语言 14 天前 通过 52 ms 8.1 MB python3 14 天前 通过 7976 ms 7.3 MB python3 第一次提交的堪堪没有超时，因为是直接双for循环暴力解决的。。。1234567891011121314class Solution: def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if len(nums) &lt; 2: return for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == target: return[i, j] 后来仔细想了想用了dict解决，效率还好。1234567891011121314class Solution: def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ dict = &#123;&#125; for i in range(len(nums)): temp = target - nums[i] if nums[i] in dict: return [dict[nums[i]], i] else: dict[temp] = i 整数反转给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。示例1： 输入: 123 输出: 321 示例2： 输入: -123 输出: -321 示例3： 输入: 120 输出: 21 注意：假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31^, 2^31^ − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 提交时间 状态 执行用时 内存消耗 语言 8 小时前 通过 140 ms 13.3 MB python3 8 小时前 解答错误 N/A N/A python3 8 小时前 执行出错 N/A N/A python3 不得不说还是太粗心大意，一开始都没看到示例2，3，就直接提交，直接执行出错了。 第一次的代码：12345678910class Solution: def reverse(self, x: int) -&gt; int: x = str(x) y = '' for i in x: y = i + y y = int(y) if -2**31&lt;y&lt;2**31-1: return y return 0 提交记录 执行出错信息： Line 7: ValueError: invalid literal for int() with base 10: ‘321-‘ 最后执行的输入： -123 第二次的代码：123456789101112131415class Solution: def reverse(self, x: int) -&gt; int: x1 = str(x) y = '' x = '' if x1[0] == '-': x += '-' for i in x1: y = i + y y = y.rstrip('-') y = x + y y = int(y) if -2**31&lt;y&lt;2**31-1: print(y) return 0 提交记录 输入： 123 输出： 0 预期： 321 最终提交如下，strip方法真的是这次用了才熟悉了。123456789101112131415class Solution: def reverse(self, x: int) -&gt; int: x1 = str(x) y = '' x = '' if x1[0] == '-': x += '-' for i in x1: y = i + y y = y.rstrip('-') y = x + y y = int(y) if -2**31&lt;y&lt;2**31-1: return y return 0 回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 好吧，我想说不能23333，真的是菜鸡本菜了 提交时间 状态 执行用时 内存消耗 语言 8 小时前 通过 276 ms 13.5 MB python3 8 小时前 解答错误 N/A N/A python3 第一次提交代码如下：1234567891011class Solution: def isPalindrome(self, x: int) -&gt; bool: str_x = str(x) y = '' if str_x[0] == '-': return False for i in str_x: y = i + y y = int(y) if x == y: return True 提交记录 输入： 10 输出： null 预期： false 最终结果如下：12345678910111213class Solution: def isPalindrome(self, x: int) -&gt; bool: str_x = str(x) y = '' if str_x[0] == '-': return False for i in str_x: y = i + y y = int(y) if x == y: return True else: return False 罗马数字转整数罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: &quot;III&quot; 输出: 3 示例 2: 输入: &quot;IV&quot; 输出: 4 示例 3: 输入: &quot;IX&quot; 输出: 9 示例 4: 输入: &quot;LVIII&quot; 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5: 输入: &quot;MCMXCIV&quot; 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 这题我一开始真的是， 我枯了emmm，思来想去最后用了n个if解决了。。。。。。 提交时间 状态 执行用时 内存消耗 语言 7 小时前 通过 248 ms 13.4 MB python3 7 小时前 解答错误 N/A N/A python3 本来以为第一次提交就直接ok，没想到出错了。。12345678910111213141516171819202122232425262728293031class Solution: def romanToInt(self, s: str) -&gt; int: dict = &#123;'I': 1,'V': 5,'X': 10, 'L': 50,'C': 100,'D': 500,'M': 1000&#125; sum = 0 if len(s) == 1: return dict[s] for i in range(len(s)): if s[i-1] == 'I': if s[i] == 'V' or s[i] == 'X': sum -= 1 else: sum += 1 if s[i-1] == 'V': sum += 5 if s[i-1] == 'X': if s[i] == 'L' or s[i] == 'C': sum -= 10 else: sum += 10 if s[i-1] == 'L': sum += 50 if s[i-1] == 'C': if s[i] == 'D' or s[i] == 'M': sum -= 100 else: sum += 100 if s[i-1] == 'D': sum += 500 if s[i-1] == 'M': sum += 1000 return sum 提交记录 输入： “MMMCDXC” 输出： 3290 预期： 3490 放debug里面跑了一遍才发现是Python for循环的问题。如下改用while循环后正常了。123456789101112131415161718192021222324252627282930313233343536class Solution: def romanToInt(self, s: str) -&gt; int: dict = &#123;'I': 1,'V': 5,'X': 10, 'L': 50,'C': 100,'D': 500,'M': 1000&#125; sum = 0 i = 0 if len(s) == 1: return dict[s] s = s + ' ' while i &lt; len(s): if i == 0: i += 1 if s[i-1] == 'I': if s[i] == 'V' or s[i] == 'X': sum -= 1 else: sum += 1 if s[i-1] == 'V': sum += 5 if s[i-1] == 'X': if s[i] == 'L' or s[i] == 'C': sum -= 10 else: sum += 10 if s[i-1] == 'L': sum += 50 if s[i-1] == 'C': if s[i] == 'D' or s[i] == 'M': sum -= 100 else: sum += 100 if s[i-1] == 'D': sum += 500 if s[i-1] == 'M': sum += 1000 i += 1 return sum 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] 输出: &quot;fl&quot; 示例 2: 输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;] 输出: &quot;&quot; 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。|提交时间|状态|执行用时|内存消耗|语言||:——:|:——:|:——:|:——:|:——:|:——:||7 小时前| 通过 |56 ms |13.2 MB| python3| 这道题我一开始想偏了，一直想着怎么遍历怎么怎么，半天解决不了。最后本菜只能参考官方题解Java版然后用Python写了出来 下面是官方题解12345678910 public String longestCommonPrefix(String[] strs) &#123; if (strs.length == 0) return ""; String prefix = strs[0]; for (int i = 1; i &lt; strs.length; i++) while (strs[i].indexOf(prefix) != 0) &#123; prefix = prefix.substring(0, prefix.length() - 1); if (prefix.isEmpty()) return ""; &#125; return prefix;&#125; 下面是我用Python改了一遍的。(哭~~） Python 没有indexof这里想到了用find替代，然后下面切割字符串刚刚好Python的切片。12345678910111213141516class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: i = 1 if len(strs) == 0: return '' if len(strs) == 1: return strs[0] if len(strs) &gt; 1: temp = strs[0] while i &lt; len(strs): while strs[i].find(temp) != 0: temp = temp[0:len(temp) - 1] if temp == '': return '' i += 1 return temp 慢慢来吧。菜鸡终有出头日]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Leecode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
