<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[菜鸡的Leecode学习-day02]]></title>
    <url>%2F2019%2F03%2F17%2F%E8%8F%9C%E9%B8%A1%E7%9A%84Leecode%E5%AD%A6%E4%B9%A0-day02%2F</url>
    <content type="text"><![CDATA[一周前做的了，今天刚好有空写到blog里，以后尽量每天一次吧 只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入：[2,2,1] 输出：1 示例 2: 输入: [4,1,2,1,2] 输出: 4 提交时间 状态 执行用时 内存消耗 语言 10 天前 通过 156 ms 35.2 MB javascript 12345678910/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var singleNumber = function(nums) &#123; for(var i = 1; i &lt; nums.length; i++)&#123; nums[0] = nums[0] ^ nums[i] &#125; return nums[0]&#125;; 其余元素均出现两次，只有所求元素一次，所以异或即可 求众数给定一个大小为n的数组，找到其中的众数。众数是指在数组中出现次数大于[n/2]的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3] 输出: 3 示例 2: 输入: [2,2,1,1,1,2,2] 输出: 2 提交时间 状态 执行用时 内存消耗 语言 10 天前 通过 108 ms 38.2 MB javascript 123456789101112131415161718/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var majorityElement = function(nums) &#123; var res = 0, count = 0 for (var num of nums)&#123; if (count === 0) &#123; res = num count++ &#125; else if (res === num) &#123; count++ &#125; else &#123; count-- &#125; &#125; return res&#125;; 先假设res为第一个数，开始遍历，相同+1,不同-1,如果count===0，res下一个数继续，最终可获得结果。 搜索二维矩阵编写一个高效的算法来搜索mxn矩阵matrix中的一个目标值target。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回true。 给定 target = 20，返回false。 提交时间 状态 执行用时 内存消耗 语言 10 天前 通过 180 ms 37.3 MB javascript 10 天前 执行出错 N/A N/A javascript 10 天前 执行出错 N/A N/A javascript 10 天前 通过 768 ms 37 MB javascript 执行用时768ms1234567891011121314/** * @param &#123;number[][]&#125; matrix * @param &#123;number&#125; target * @return &#123;boolean&#125; */var searchMatrix = function(matrix, target) &#123; for(let i = 0; i &lt; matrix.length; i++) &#123; for (let j = 0; j &lt; matrix[0].length; j++)&#123; if(matrix[i][j] === target)&#123; return true &#125; &#125; &#125;return false&#125;; 感觉应该很无脑了2333，直接遍历所有。 执行用时180ms1234567891011121314151617181920212223/** * @param &#123;number[][]&#125; matrix * @param &#123;number&#125; target * @return &#123;boolean&#125; */var searchMatrix = function(matrix, target) &#123; if(matrix.length &lt; 1 || matrix.length[0] &lt; 1) &#123; return false &#125; let row = matrix.length, col = matrix[0].length, i = row - 1, j = 0 while(i &gt;= 0 &amp;&amp; j &lt; col) &#123; if (matrix[i][j] &gt; target) &#123; i-- &#125; else if (matrix[i][j] &lt; target) &#123; j++ &#125; else if (matrix[i][j] === target)&#123; return true &#125; else &#123; return false &#125; &#125; return false&#125;; 取矩阵左下角为锚点，其余元素有个特性，在其上的总小于锚点值，右边的总大于锚点值。之后比较大小即可。 合并两个有序数组给定两个有序整数数组nums1和nums2,将nums2合并到nums1中，使得num1成为一个有序数组。 说明: 初始化nums1和nums2的元素数量分别为m和n。你可以假设nums1有足够的空间（空间大小大于或等于 m + n）来保存nums2中的元素。示例: 输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 提交时间 状态 执行用时 内存消耗 语言 10 天前 通过 104 ms 34.6 MB javascript 1234567891011121314/** * @param &#123;number[]&#125; nums1 * @param &#123;number&#125; m * @param &#123;number[]&#125; nums2 * @param &#123;number&#125; n * @return &#123;void&#125; Do not return anything, modify nums1 in-place instead. */var merge = function(nums1, m, nums2, n) &#123; nums1 = nums1.reverse() for (let i = 0; i &lt; nums2.length; i++) &#123; nums1[i] += nums2[i] &#125; nums1 = nums1.sort((a,b) =&gt; &#123;return a - b&#125;)&#125;; 取巧写法~~~ 捂脸···]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Leecode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript继承]]></title>
    <url>%2F2019%2F03%2F09%2FJavaScript%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[接之前的坑，重新复习一遍继承 原型链Js中描述了原型链的概念，并将原型链作为实现继承的主要方法。基本思想便是利用原型让一个引用类型继承另一个引用类型的属性和方法。 实现原型链的基本模式123456789101112131415161718192021function SuperType () &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function () &#123; return this.property;&#125;function SubType () &#123; this.subproperty = false;&#125;// 继承了 SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function () &#123; return this.subproperty;&#125;var instance = new SubType();alert(instance.getSuperValue()); // true SubType继承自SuperType。继承通过创建SuperType的示例，并将该实例赋给SubType.prototype实现。本质为重写原型对象，代之以一个新类型的示例。确立继承之后，再在SubType.prototype添加一个方法，这样就在继承SuperType的属性和方法基础上添加了新方法。 总之，SubType继承SuperType，SuperType继承自Object。当调用instance.toString()时，实际调用的是保存在Object.prototype中的方法。 子类重写超类中的方法或者添加超类不存在的方法时，一定要放在替换原型的语句之后。 存在的问题： 包含引用类型值的原型。 eg.123456789101112131415function SuperType() &#123; this.colors = ["red", "blue", "green"];&#125;function SubType() &#123;&#125;// 继承SubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push("black");alert(instance1.colors); // "red,blue,green,black"var instance2 = new SubType();alert(instance2.colors); // "red,blue,green,black" 结果显而易见，子类的所有实例共享属性。 创建子类型实例时，不能向超类型的构造函数中传递参数。(无法再不影响所有对象实例的情况下，给超类的构造函数传递参数) 实际很少单独使用原型链方法 借用构造函数 借用构造函数(constructor stealing),即(伪造对象或经典继承).通过在子类型构造函数的内部调用超类型构造函数实现。使用apply()和call()`方法。 123456789101112131415function SuperType() &#123; this.colors = ["red", "blue", "green"];&#125;function SubType() &#123; // 继承 SuperType.call(this);&#125;var instance1 = new SubType();instance1.colors.push("black");alert(instance1.colors); // "red,blue,green,black"var instance2 = new SubType();alert(instance2.colors); // "red,blue,green" 上式通过在SubType()实例下调用了SuperType构造函数。 相对于原型链方式的优势 1234567891011121314function SuperType(name) &#123; this.name = name;&#125;function SubType() &#123; // 继承，传递参数 SuperType.call(this, "Nicholas"); // 实例属性 this.age = 29;&#125;var instance = new SubType();alert(instance.name); // Nicholasalert(instace.age); // 29 SuperType()只接受一个参数，在SubType()构造函数中调用会为SubType()实例设置 name属性。在此之后再添加应该在子类型中定义的属性防止SuperType()构造函数重写子类属性。 存在的问题 函数无法复用，超类原型定义的方法子类也不可见，即所有类型只能使用构造函数模式。 因此很少单独使用构造函数方式 组合继承组合继承(combination inheritance),经典伪继承，即将原型链和构造函数方式合用，从而发挥二者之长。 思路是使用原型链实现对原型属性和方法的继承，通过构造函数实现对实例属性的继承。既保证在原型上定义方法实现了函数复用，又保证每个实例都有自己的属性。1234567891011121314151617181920212223242526272829303132function SuperType(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;function SubType(name, age) &#123; // 继承属性 SuperType.call(this, name); this.age = age;&#125;// 继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() &#123; alert(this.age);&#125;var instance1 = new SubType("Nicholas", 29);instance1.colors.push("black");alert(instance1.colors); // "red,blue,green,black"instance1.sayName(); // "Nicholas"instance1.sayAge(); // 29var instance2 = new SubType("Greg", 27);alert(instance2.colors); // "red,blue,green"instance2.sayName(); // "Greg"instance2.sayAge(); // 27 原型式继承 在object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。 1234567891011121314var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"]&#125;;var person1 = object(person);person1.name = "Greg";person1.friends.push("Rob");var person2 = object(person);person2.name = "Linda";person2.friends.push("Barbie");alert(person.friends); // "Shelby,Court,Van,Rob,Barbie 寄生式继承 寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。 1234567function createAnother(original) &#123; var clone = object(original); // 通过调用函数创建一个对象 clone.sayHi = function() &#123; // 以某种方式来增强这个对象 alert("hi"); &#125;; return clone; //返回这个对象&#125; 使用如下1234567var person = &#123; name: 'Nicholas', friends: ["Shelby", "Court", "Van"]&#125;;var person1 = createAnother(person);person1.sayHi(); // "hi" 寄生组合式继承 组合式继承无论什么情况下都会调用两次超类构造函数，一次是创建子类型原型，一次是子类型构造函数内部。 123456789101112131415161718192021function SuperType(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;function SubType(name, age) &#123; // 继承属性 SuperType.call(this, name); // 第二次调用SuperType() this.age = age;&#125;// 继承方法SubType.prototype = new SuperType(); // 第一次调用 SuperType()SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() &#123; alert(this.age);&#125; 第一次调用时SubType.prototype得到两个属性:name、colors(此时位于SubType原型).第二次调用SubType时在新对象上创建了实例属性name和colors。新创建的属性屏蔽了原型中的同名属性。 寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。 基本思路：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已 本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。 eg.12345function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); // 创建对象 prototype.constructor = subType; // 增强对象 subType.prototype = prototype; // 指定对象&#125; 上式inheritPrototype()接收两个参数：子类构造函数和超类构造函数。 在函数内部： 创建超类原型的副本 为创建的副本添加constructor属性，弥补因重写原型失去的默认constructor属性 将新创建的对象赋值给子类型的原型。 12345678910111213141516171819function SuperType(name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function() &#123; alert(this.age);&#125; 这个例子的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了在SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用instanceof和isPrototypeOf()。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript引用类型的Array类型]]></title>
    <url>%2F2019%2F03%2F04%2FJavaScript%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84Array%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[鄙渣学了一学期的JavaScript，无奈并没有学通，最终还是祭出了Js红宝书，从头预习 转换方法所有对象都具有 toLocaleString()、toString()和valueOf()方法。 12345678910111213141516171819var person1 = &#123; toLocaleString : function () &#123; return "Nikolaos"; &#125;, toString : function() &#123; return "Nikolaos"; &#125;&#125;;var person2 = &#123; toLocaleString : function () &#123; return "Grigorios"; &#125;, toString : function () &#123; return "Greg"; &#125;&#125;; 1234var people = [person1, person2];alert(people); // Nicholas,Gregalert(people.toString()); // Nicholas,Gregalert(people.toLocaleString()); // Nicholas,Grigorios RT,默认调用的是toString()同下一行显式调用。 eg:可以使用join()更改字符串的分隔方式12var colors = ["red", "green", "blue"];alert(colors.join("|")); // red|green|blue 栈方法栈即是需要后进先出的，Js也为此提供了push()和pop()方法用以实现栈的LIFO(Last-In-First-Out)。 123456789101112var colors = new Array();var count = colors.push("red", "green");alert(count); // 2alert(colors); // red,greencount = colors.push("black");alert(count); // 3alert(colors); // red,green,blackvar item = colors.pop();alert(item); // "black"alert(colors.length); // 2 队列方法队列的访问方式是FIFO(First-In-First-Out)，Js也有相应的shift()和unshift()方法。 12345678910111213var colors = new Array();var count = colors.push("red", "green");alert(count); // 2alert(colors); // red,greencount = colors.push("black");alert(count); // 3alert(colors); // red,green,blackvar item = colors.shift();alert(item); // "red"alert(colors.length); // 2alert(colors); // green, black unshift()用以在数组前段添加任意个项并返回新数组长度。 重排序方法reverse()和sort(). 123var values = [1, 2, 3, 4, 5];values.reverse();alert(values); // 5, 4, 3, 2, 1 sort()的弊端.123var values = [0, 1, 5, 10, 15];values.sort();alert(values); // 0, 1, 10, 15, 5 改进方式123456789101112131415function compare(value1, value2)&#123; if (value1 &lt; value2)&#123; return -1; &#125; else if(value1 &gt; value2)&#123; return 1; &#125; else&#123; return 0; &#125;&#125;var values = [0, 1, 5, 10, 15];values.sort(compare);alert(values); // 0, 1, 5, 10, 15 操作方法concat().创建当前数组的副本，并将接收到的参数添加到副本的末尾，并返回新的数组。12345var colors = ["red", "green", "blue"];var colors2 = colors.concat("yellow", ["black", "brown"]);alert(colors); // red,green,bluealert(colors2); // red,green,blue,yellow,black,brown slice().基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。 123456var colors = ["red", "green", "blue", "yellow", "purple"];var colors2 = colors.slice(1);var colors3 = colors.slice(1, 4);alert(colors2); // green,blue,yellow,purplealert(colors3); // green,blue,yellow splice().有如下三种方法 删除: 指定2个参数，要删除的第一项的位置和要删除的项数。 插入: 指定3个参数，起始位置、0(要删除的项数)和要插入的项。 替换: 指定3个参数，起始位置、要删除的项数和要插入任意数量的项。 123456789101112var colors = ["red", "green", "blue"];var removed = colors.splice(0,1); // 删除第一项alert(colors); // green,bluealert(removed); // red，返回的数组中只包含一项removed = colors.splice(1, 0, "yellow", "orange"); // 从位置1开始插入两项alert(colors); // green,yellow,orange,bluealert(removed); // 返回的是一个空数组removed = colors.splice(1, 1, "red", "purple"); // 插入两项，删除一项alert(colors); // green,red,purple,orange,bluealert(removed); // yellow，返回的数组中只包含一项 位置方法indexOf()和lastIndexOf().均接收两个参数：要查找的项和(可选)查找起点位置的索引。 123456789101112131415var numbers = [1,2,3,4,5,4,3,2,1];alert(numbers.indexOf(4)); //3alert(numbers.lastIndexOf(4)); //5alert(numbers.indexOf(4, 4)); //5alert(numbers.lastIndexOf(4, 4)); //3var person = &#123; name: "Nicholas" &#125;;var people = [&#123; name: "Nicholas" &#125;];var morePeople = [person];alert(people.indexOf(person)); //-1alert(morePeople.indexOf(person)); //0 迭代方法 every():对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回true。 filter():对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。 forEach():对数组中的每一项运行给定函数，无返回值。 map():对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some():对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。 1234567var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(everyResult); //false 1234567var numbers = [1,2,3,4,5,4,3,2,1];var filterResult = numbers.filter(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(filterResult); // [3, 4, 5, 4, 3] 1234567var numbers = [1,2,3,4,5,4,3,2,1];var mapResult = numbers.map(function(item, index, array)&#123; return item * 2;&#125;);alert(mapResult); // [2, 4, 6, 8, 10, 8, 6, 4, 2] 123456var numbers = [1,2,3,4,5,4,3,2,1];numbers.forEach(function(item, index, array)&#123; //执行操作 // forEach 本质上等同于使用for循环&#125;) 1234567var numbers = [1,2,3,4,5,4,3,2,1];var someResult = numbers.some(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(someResult); //true 归并方法 reduce():迭代数组所有项，从左向右。 reduceRight():迭代数组所有项，从右向左。 1234567var values = [1, 2, 3, 4, 5];var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum); // 15 初次执行，prev = 1, cur = 2 第二次执行，prev = 3, cur = 3 持续到遍历所有项 reduceRight()同理。 初次执行，prev = 5, cur = 4 第二次执行，prev = 9, cur = 3 持续到遍历所有项]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸡的Leecode学习-day01]]></title>
    <url>%2F2019%2F02%2F26%2F%E8%8F%9C%E9%B8%A1%E7%9A%84Leecode%E5%AD%A6%E4%B9%A0-day01%2F</url>
    <content type="text"><![CDATA[写在最先 之前博客用的个人域名然后放在vultr上，前阵子不知道怎么出问题了，访问特别困难，后来发现dnspod解析也需要备案，思来想去干脆直接在github上写了，以前那点文章也懒得恢复了！ 最近开始在Leecode上刷题，先从简单的开始，嘿嘿！刚好在博客上也做一番记录，算是让自己记忆更深吧。 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例： 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 提交时间 状态 执行用时 内存消耗 语言 14 天前 通过 52 ms 8.1 MB python3 14 天前 通过 7976 ms 7.3 MB python3 第一次提交的堪堪没有超时，因为是直接双for循环暴力解决的。。。1234567891011121314class Solution: def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if len(nums) &lt; 2: return for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == target: return[i, j] 后来仔细想了想用了dict解决，效率还好。1234567891011121314class Solution: def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ dict = &#123;&#125; for i in range(len(nums)): temp = target - nums[i] if nums[i] in dict: return [dict[nums[i]], i] else: dict[temp] = i 整数反转给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。示例1： 输入: 123 输出: 321 示例2： 输入: -123 输出: -321 示例3： 输入: 120 输出: 21 注意：假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31^, 2^31^ − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 提交时间 状态 执行用时 内存消耗 语言 8 小时前 通过 140 ms 13.3 MB python3 8 小时前 解答错误 N/A N/A python3 8 小时前 执行出错 N/A N/A python3 不得不说还是太粗心大意，一开始都没看到示例2，3，就直接提交，直接执行出错了。 第一次的代码：12345678910class Solution: def reverse(self, x: int) -&gt; int: x = str(x) y = '' for i in x: y = i + y y = int(y) if -2**31&lt;y&lt;2**31-1: return y return 0 提交记录 执行出错信息： Line 7: ValueError: invalid literal for int() with base 10: ‘321-‘ 最后执行的输入： -123 第二次的代码：123456789101112131415class Solution: def reverse(self, x: int) -&gt; int: x1 = str(x) y = '' x = '' if x1[0] == '-': x += '-' for i in x1: y = i + y y = y.rstrip('-') y = x + y y = int(y) if -2**31&lt;y&lt;2**31-1: print(y) return 0 提交记录 输入： 123 输出： 0 预期： 321 最终提交如下，strip方法真的是这次用了才熟悉了。123456789101112131415class Solution: def reverse(self, x: int) -&gt; int: x1 = str(x) y = '' x = '' if x1[0] == '-': x += '-' for i in x1: y = i + y y = y.rstrip('-') y = x + y y = int(y) if -2**31&lt;y&lt;2**31-1: return y return 0 回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 好吧，我想说不能23333，真的是菜鸡本菜了 提交时间 状态 执行用时 内存消耗 语言 8 小时前 通过 276 ms 13.5 MB python3 8 小时前 解答错误 N/A N/A python3 第一次提交代码如下：1234567891011class Solution: def isPalindrome(self, x: int) -&gt; bool: str_x = str(x) y = '' if str_x[0] == '-': return False for i in str_x: y = i + y y = int(y) if x == y: return True 提交记录 输入： 10 输出： null 预期： false 最终结果如下：12345678910111213class Solution: def isPalindrome(self, x: int) -&gt; bool: str_x = str(x) y = '' if str_x[0] == '-': return False for i in str_x: y = i + y y = int(y) if x == y: return True else: return False 罗马数字转整数罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: &quot;III&quot; 输出: 3 示例 2: 输入: &quot;IV&quot; 输出: 4 示例 3: 输入: &quot;IX&quot; 输出: 9 示例 4: 输入: &quot;LVIII&quot; 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5: 输入: &quot;MCMXCIV&quot; 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 这题我一开始真的是， 我枯了emmm，思来想去最后用了n个if解决了。。。。。。 提交时间 状态 执行用时 内存消耗 语言 7 小时前 通过 248 ms 13.4 MB python3 7 小时前 解答错误 N/A N/A python3 本来以为第一次提交就直接ok，没想到出错了。。12345678910111213141516171819202122232425262728293031class Solution: def romanToInt(self, s: str) -&gt; int: dict = &#123;'I': 1,'V': 5,'X': 10, 'L': 50,'C': 100,'D': 500,'M': 1000&#125; sum = 0 if len(s) == 1: return dict[s] for i in range(len(s)): if s[i-1] == 'I': if s[i] == 'V' or s[i] == 'X': sum -= 1 else: sum += 1 if s[i-1] == 'V': sum += 5 if s[i-1] == 'X': if s[i] == 'L' or s[i] == 'C': sum -= 10 else: sum += 10 if s[i-1] == 'L': sum += 50 if s[i-1] == 'C': if s[i] == 'D' or s[i] == 'M': sum -= 100 else: sum += 100 if s[i-1] == 'D': sum += 500 if s[i-1] == 'M': sum += 1000 return sum 提交记录 输入： “MMMCDXC” 输出： 3290 预期： 3490 放debug里面跑了一遍才发现是Python for循环的问题。如下改用while循环后正常了。123456789101112131415161718192021222324252627282930313233343536class Solution: def romanToInt(self, s: str) -&gt; int: dict = &#123;'I': 1,'V': 5,'X': 10, 'L': 50,'C': 100,'D': 500,'M': 1000&#125; sum = 0 i = 0 if len(s) == 1: return dict[s] s = s + ' ' while i &lt; len(s): if i == 0: i += 1 if s[i-1] == 'I': if s[i] == 'V' or s[i] == 'X': sum -= 1 else: sum += 1 if s[i-1] == 'V': sum += 5 if s[i-1] == 'X': if s[i] == 'L' or s[i] == 'C': sum -= 10 else: sum += 10 if s[i-1] == 'L': sum += 50 if s[i-1] == 'C': if s[i] == 'D' or s[i] == 'M': sum -= 100 else: sum += 100 if s[i-1] == 'D': sum += 500 if s[i-1] == 'M': sum += 1000 i += 1 return sum 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] 输出: &quot;fl&quot; 示例 2: 输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;] 输出: &quot;&quot; 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。|提交时间|状态|执行用时|内存消耗|语言||:——:|:——:|:——:|:——:|:——:||7 小时前| 通过 |56 ms |13.2 MB| python3| 这道题我一开始想偏了，一直想着怎么遍历怎么怎么，半天解决不了。最后本菜只能参考官方题解Java版然后用Python写了出来 下面是官方题解12345678910 public String longestCommonPrefix(String[] strs) &#123; if (strs.length == 0) return ""; String prefix = strs[0]; for (int i = 1; i &lt; strs.length; i++) while (strs[i].indexOf(prefix) != 0) &#123; prefix = prefix.substring(0, prefix.length() - 1); if (prefix.isEmpty()) return ""; &#125; return prefix;&#125; 下面是我用Python改了一遍的。(哭~~） Python 没有indexof这里想到了用find替代，然后下面切割字符串刚刚好Python的切片。12345678910111213141516class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: i = 1 if len(strs) == 0: return '' if len(strs) == 1: return strs[0] if len(strs) &gt; 1: temp = strs[0] while i &lt; len(strs): while strs[i].find(temp) != 0: temp = temp[0:len(temp) - 1] if temp == '': return '' i += 1 return temp 慢慢来吧。菜鸡终有出头日]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Leecode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
